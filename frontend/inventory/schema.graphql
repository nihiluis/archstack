schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# columns and relationships of "document"
type document implements Node {
  # An array relationship
  children(
    # distinct select on columns
    distinct_on: [document_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_order_by!]

    # filter the rows returned
    where: document_bool_exp
  ): [document!]!

  # An aggregated array relationship
  children_aggregate(
    # distinct select on columns
    distinct_on: [document_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_order_by!]

    # filter the rows returned
    where: document_bool_exp
  ): document_aggregate!

  # An array relationship connection
  children_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_order_by!]

    # filter the rows returned
    where: document_bool_exp
  ): documentConnection!
  created_at: timestamptz
  description: String!
  external_id: String

  # An array relationship
  field_values(
    # distinct select on columns
    distinct_on: [field_value_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [field_value_order_by!]

    # filter the rows returned
    where: field_value_bool_exp
  ): [field_value!]!

  # An aggregated array relationship
  field_values_aggregate(
    # distinct select on columns
    distinct_on: [field_value_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [field_value_order_by!]

    # filter the rows returned
    where: field_value_bool_exp
  ): field_value_aggregate!

  # An array relationship connection
  field_values_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [field_value_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [field_value_order_by!]

    # filter the rows returned
    where: field_value_bool_exp
  ): field_valueConnection!

  # An array relationship
  from_relations(
    # distinct select on columns
    distinct_on: [document_relation_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_relation_order_by!]

    # filter the rows returned
    where: document_relation_bool_exp
  ): [document_relation!]!

  # An aggregated array relationship
  from_relations_aggregate(
    # distinct select on columns
    distinct_on: [document_relation_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_relation_order_by!]

    # filter the rows returned
    where: document_relation_bool_exp
  ): document_relation_aggregate!

  # An array relationship connection
  from_relations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_relation_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_relation_order_by!]

    # filter the rows returned
    where: document_relation_bool_exp
  ): document_relationConnection!
  id: ID!
  name: String!

  # An object relationship
  parent: document
  parent_id: uuid

  # An array relationship
  to_relations(
    # distinct select on columns
    distinct_on: [document_relation_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_relation_order_by!]

    # filter the rows returned
    where: document_relation_bool_exp
  ): [document_relation!]!

  # An aggregated array relationship
  to_relations_aggregate(
    # distinct select on columns
    distinct_on: [document_relation_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_relation_order_by!]

    # filter the rows returned
    where: document_relation_bool_exp
  ): document_relation_aggregate!

  # An array relationship connection
  to_relations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_relation_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_relation_order_by!]

    # filter the rows returned
    where: document_relation_bool_exp
  ): document_relationConnection!

  # An object relationship
  type: document_type
  type_id: uuid!
  updated_at: timestamptz
}

# aggregated selection of "document"
type document_aggregate {
  aggregate: document_aggregate_fields
  nodes: [document!]!
}

# aggregate fields of "document"
type document_aggregate_fields {
  count(columns: [document_select_column!], distinct: Boolean): Int
  max: document_max_fields
  min: document_min_fields
}

# order by aggregate values of table "document"
input document_aggregate_order_by {
  count: order_by
  max: document_max_order_by
  min: document_min_order_by
}

# input type for inserting array relation for remote table "document"
input document_arr_rel_insert_input {
  data: [document_insert_input!]!
  on_conflict: document_on_conflict
}

# Boolean expression to filter rows from the table "document". All fields are combined with a logical 'AND'.
input document_bool_exp {
  _and: [document_bool_exp]
  _not: document_bool_exp
  _or: [document_bool_exp]
  children: document_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  external_id: String_comparison_exp
  field_values: field_value_bool_exp
  from_relations: document_relation_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  parent: document_bool_exp
  parent_id: uuid_comparison_exp
  to_relations: document_relation_bool_exp
  type: document_type_bool_exp
  type_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "document"
enum document_constraint {
  # unique or primary key constraint
  document_pkey
}

# input type for inserting data into table "document"
input document_insert_input {
  children: document_arr_rel_insert_input
  created_at: timestamptz
  description: String
  external_id: String
  field_values: field_value_arr_rel_insert_input
  from_relations: document_relation_arr_rel_insert_input
  id: uuid
  name: String
  parent: document_obj_rel_insert_input
  parent_id: uuid
  to_relations: document_relation_arr_rel_insert_input
  type: document_type_obj_rel_insert_input
  type_id: uuid
  updated_at: timestamptz
}

# aggregate max on columns
type document_max_fields {
  created_at: timestamptz
  description: String
  external_id: String
  id: uuid
  name: String
  parent_id: uuid
  type_id: uuid
  updated_at: timestamptz
}

# order by max() on columns of table "document"
input document_max_order_by {
  created_at: order_by
  description: order_by
  external_id: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  type_id: order_by
  updated_at: order_by
}

# aggregate min on columns
type document_min_fields {
  created_at: timestamptz
  description: String
  external_id: String
  id: uuid
  name: String
  parent_id: uuid
  type_id: uuid
  updated_at: timestamptz
}

# order by min() on columns of table "document"
input document_min_order_by {
  created_at: order_by
  description: order_by
  external_id: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  type_id: order_by
  updated_at: order_by
}

# response of any mutation on the table "document"
type document_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document!]!
}

# input type for inserting object relation for remote table "document"
input document_obj_rel_insert_input {
  data: document_insert_input!
  on_conflict: document_on_conflict
}

# on conflict condition type for table "document"
input document_on_conflict {
  constraint: document_constraint!
  update_columns: [document_update_column!]!
  where: document_bool_exp
}

# ordering options when selecting data from "document"
input document_order_by {
  children_aggregate: document_aggregate_order_by
  created_at: order_by
  description: order_by
  external_id: order_by
  field_values_aggregate: field_value_aggregate_order_by
  from_relations_aggregate: document_relation_aggregate_order_by
  id: order_by
  name: order_by
  parent: document_order_by
  parent_id: order_by
  to_relations_aggregate: document_relation_aggregate_order_by
  type: document_type_order_by
  type_id: order_by
  updated_at: order_by
}

# primary key columns input for table: "document"
input document_pk_columns_input {
  id: uuid!
}

# columns and relationships of "document_relation"
type document_relation implements Node {
  # An object relationship
  from: document!
  from_id: uuid!
  id: ID!

  # An object relationship
  to: document!
  to_id: uuid!

  # An object relationship
  type: document_relation_type!
  type_id: uuid!
}

# aggregated selection of "document_relation"
type document_relation_aggregate {
  aggregate: document_relation_aggregate_fields
  nodes: [document_relation!]!
}

# aggregate fields of "document_relation"
type document_relation_aggregate_fields {
  count(columns: [document_relation_select_column!], distinct: Boolean): Int
  max: document_relation_max_fields
  min: document_relation_min_fields
}

# order by aggregate values of table "document_relation"
input document_relation_aggregate_order_by {
  count: order_by
  max: document_relation_max_order_by
  min: document_relation_min_order_by
}

# input type for inserting array relation for remote table "document_relation"
input document_relation_arr_rel_insert_input {
  data: [document_relation_insert_input!]!
  on_conflict: document_relation_on_conflict
}

# Boolean expression to filter rows from the table "document_relation". All fields are combined with a logical 'AND'.
input document_relation_bool_exp {
  _and: [document_relation_bool_exp]
  _not: document_relation_bool_exp
  _or: [document_relation_bool_exp]
  from: document_bool_exp
  from_id: uuid_comparison_exp
  id: uuid_comparison_exp
  to: document_bool_exp
  to_id: uuid_comparison_exp
  type: document_relation_type_bool_exp
  type_id: uuid_comparison_exp
}

# unique or primary key constraints on table "document_relation"
enum document_relation_constraint {
  # unique or primary key constraint
  document_relation_pkey
}

# input type for inserting data into table "document_relation"
input document_relation_insert_input {
  from: document_obj_rel_insert_input
  from_id: uuid
  id: uuid
  to: document_obj_rel_insert_input
  to_id: uuid
  type: document_relation_type_obj_rel_insert_input
  type_id: uuid
}

# aggregate max on columns
type document_relation_max_fields {
  from_id: uuid
  id: uuid
  to_id: uuid
  type_id: uuid
}

# order by max() on columns of table "document_relation"
input document_relation_max_order_by {
  from_id: order_by
  id: order_by
  to_id: order_by
  type_id: order_by
}

# aggregate min on columns
type document_relation_min_fields {
  from_id: uuid
  id: uuid
  to_id: uuid
  type_id: uuid
}

# order by min() on columns of table "document_relation"
input document_relation_min_order_by {
  from_id: order_by
  id: order_by
  to_id: order_by
  type_id: order_by
}

# response of any mutation on the table "document_relation"
type document_relation_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_relation!]!
}

# input type for inserting object relation for remote table "document_relation"
input document_relation_obj_rel_insert_input {
  data: document_relation_insert_input!
  on_conflict: document_relation_on_conflict
}

# on conflict condition type for table "document_relation"
input document_relation_on_conflict {
  constraint: document_relation_constraint!
  update_columns: [document_relation_update_column!]!
  where: document_relation_bool_exp
}

# ordering options when selecting data from "document_relation"
input document_relation_order_by {
  from: document_order_by
  from_id: order_by
  id: order_by
  to: document_order_by
  to_id: order_by
  type: document_relation_type_order_by
  type_id: order_by
}

# primary key columns input for table: "document_relation"
input document_relation_pk_columns_input {
  id: uuid!
}

# select columns of table "document_relation"
enum document_relation_select_column {
  # column name
  from_id

  # column name
  id

  # column name
  to_id

  # column name
  type_id
}

# input type for updating data in table "document_relation"
input document_relation_set_input {
  from_id: uuid
  id: uuid
  to_id: uuid
  type_id: uuid
}

# columns and relationships of "document_relation_type"
type document_relation_type implements Node {
  bidirectional: Boolean!
  description: String!
  external_id: String

  # An object relationship
  from: document_type!
  from_id: uuid!
  from_name: String

  # An array relationship
  groups(
    # distinct select on columns
    distinct_on: [group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): [group!]!

  # An aggregated array relationship
  groups_aggregate(
    # distinct select on columns
    distinct_on: [group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): group_aggregate!

  # An array relationship connection
  groups_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [group_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): groupConnection!
  id: ID!
  name: String!

  # An object relationship
  to: document_type
  to_id: uuid
  to_name: String
}

# aggregated selection of "document_relation_type"
type document_relation_type_aggregate {
  aggregate: document_relation_type_aggregate_fields
  nodes: [document_relation_type!]!
}

# aggregate fields of "document_relation_type"
type document_relation_type_aggregate_fields {
  count(columns: [document_relation_type_select_column!], distinct: Boolean): Int
  max: document_relation_type_max_fields
  min: document_relation_type_min_fields
}

# order by aggregate values of table "document_relation_type"
input document_relation_type_aggregate_order_by {
  count: order_by
  max: document_relation_type_max_order_by
  min: document_relation_type_min_order_by
}

# input type for inserting array relation for remote table "document_relation_type"
input document_relation_type_arr_rel_insert_input {
  data: [document_relation_type_insert_input!]!
  on_conflict: document_relation_type_on_conflict
}

# Boolean expression to filter rows from the table "document_relation_type". All fields are combined with a logical 'AND'.
input document_relation_type_bool_exp {
  _and: [document_relation_type_bool_exp]
  _not: document_relation_type_bool_exp
  _or: [document_relation_type_bool_exp]
  bidirectional: Boolean_comparison_exp
  description: String_comparison_exp
  external_id: String_comparison_exp
  from: document_type_bool_exp
  from_id: uuid_comparison_exp
  from_name: String_comparison_exp
  groups: group_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  to: document_type_bool_exp
  to_id: uuid_comparison_exp
  to_name: String_comparison_exp
}

# unique or primary key constraints on table "document_relation_type"
enum document_relation_type_constraint {
  # unique or primary key constraint
  document_relation_type_pkey
}

# input type for inserting data into table "document_relation_type"
input document_relation_type_insert_input {
  bidirectional: Boolean
  description: String
  external_id: String
  from: document_type_obj_rel_insert_input
  from_id: uuid
  from_name: String
  groups: group_arr_rel_insert_input
  id: uuid
  name: String
  to: document_type_obj_rel_insert_input
  to_id: uuid
  to_name: String
}

# aggregate max on columns
type document_relation_type_max_fields {
  description: String
  external_id: String
  from_id: uuid
  from_name: String
  id: uuid
  name: String
  to_id: uuid
  to_name: String
}

# order by max() on columns of table "document_relation_type"
input document_relation_type_max_order_by {
  description: order_by
  external_id: order_by
  from_id: order_by
  from_name: order_by
  id: order_by
  name: order_by
  to_id: order_by
  to_name: order_by
}

# aggregate min on columns
type document_relation_type_min_fields {
  description: String
  external_id: String
  from_id: uuid
  from_name: String
  id: uuid
  name: String
  to_id: uuid
  to_name: String
}

# order by min() on columns of table "document_relation_type"
input document_relation_type_min_order_by {
  description: order_by
  external_id: order_by
  from_id: order_by
  from_name: order_by
  id: order_by
  name: order_by
  to_id: order_by
  to_name: order_by
}

# response of any mutation on the table "document_relation_type"
type document_relation_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_relation_type!]!
}

# input type for inserting object relation for remote table "document_relation_type"
input document_relation_type_obj_rel_insert_input {
  data: document_relation_type_insert_input!
  on_conflict: document_relation_type_on_conflict
}

# on conflict condition type for table "document_relation_type"
input document_relation_type_on_conflict {
  constraint: document_relation_type_constraint!
  update_columns: [document_relation_type_update_column!]!
  where: document_relation_type_bool_exp
}

# ordering options when selecting data from "document_relation_type"
input document_relation_type_order_by {
  bidirectional: order_by
  description: order_by
  external_id: order_by
  from: document_type_order_by
  from_id: order_by
  from_name: order_by
  groups_aggregate: group_aggregate_order_by
  id: order_by
  name: order_by
  to: document_type_order_by
  to_id: order_by
  to_name: order_by
}

# primary key columns input for table: "document_relation_type"
input document_relation_type_pk_columns_input {
  id: uuid!
}

# select columns of table "document_relation_type"
enum document_relation_type_select_column {
  # column name
  bidirectional

  # column name
  description

  # column name
  external_id

  # column name
  from_id

  # column name
  from_name

  # column name
  id

  # column name
  name

  # column name
  to_id

  # column name
  to_name
}

# input type for updating data in table "document_relation_type"
input document_relation_type_set_input {
  bidirectional: Boolean
  description: String
  external_id: String
  from_id: uuid
  from_name: String
  id: uuid
  name: String
  to_id: uuid
  to_name: String
}

# update columns of table "document_relation_type"
enum document_relation_type_update_column {
  # column name
  bidirectional

  # column name
  description

  # column name
  external_id

  # column name
  from_id

  # column name
  from_name

  # column name
  id

  # column name
  name

  # column name
  to_id

  # column name
  to_name
}

# A Relay Connection object on "document_relation_type"
type document_relation_typeConnection {
  edges: [document_relation_typeEdge!]!
  pageInfo: PageInfo!
}

type document_relation_typeEdge {
  cursor: String!
  node: document_relation_type!
}

# update columns of table "document_relation"
enum document_relation_update_column {
  # column name
  from_id

  # column name
  id

  # column name
  to_id

  # column name
  type_id
}

# A Relay Connection object on "document_relation"
type document_relationConnection {
  edges: [document_relationEdge!]!
  pageInfo: PageInfo!
}

type document_relationEdge {
  cursor: String!
  node: document_relation!
}

# select columns of table "document"
enum document_select_column {
  # column name
  created_at

  # column name
  description

  # column name
  external_id

  # column name
  id

  # column name
  name

  # column name
  parent_id

  # column name
  type_id

  # column name
  updated_at
}

# input type for updating data in table "document"
input document_set_input {
  created_at: timestamptz
  description: String
  external_id: String
  id: uuid
  name: String
  parent_id: uuid
  type_id: uuid
  updated_at: timestamptz
}

# columns and relationships of "document_type"
type document_type implements Node {
  # An array relationship
  children_hierarchy(
    # distinct select on columns
    distinct_on: [document_type_hierarchy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_type_hierarchy_order_by!]

    # filter the rows returned
    where: document_type_hierarchy_bool_exp
  ): [document_type_hierarchy!]!

  # An aggregated array relationship
  children_hierarchy_aggregate(
    # distinct select on columns
    distinct_on: [document_type_hierarchy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_type_hierarchy_order_by!]

    # filter the rows returned
    where: document_type_hierarchy_bool_exp
  ): document_type_hierarchy_aggregate!

  # An array relationship connection
  children_hierarchy_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_hierarchy_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_hierarchy_order_by!]

    # filter the rows returned
    where: document_type_hierarchy_bool_exp
  ): document_type_hierarchyConnection!
  color: String!
  created_at: timestamptz
  description: String!
  external_id: String!

  # An array relationship
  fields(
    # distinct select on columns
    distinct_on: [document_type_document_field_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_type_document_field_order_by!]

    # filter the rows returned
    where: document_type_document_field_bool_exp
  ): [document_type_document_field!]!

  # An aggregated array relationship
  fields_aggregate(
    # distinct select on columns
    distinct_on: [document_type_document_field_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_type_document_field_order_by!]

    # filter the rows returned
    where: document_type_document_field_bool_exp
  ): document_type_document_field_aggregate!

  # An array relationship connection
  fields_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_document_field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_document_field_order_by!]

    # filter the rows returned
    where: document_type_document_field_bool_exp
  ): document_type_document_fieldConnection!

  # An array relationship
  from_relation_types(
    # distinct select on columns
    distinct_on: [document_relation_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_relation_type_order_by!]

    # filter the rows returned
    where: document_relation_type_bool_exp
  ): [document_relation_type!]!

  # An aggregated array relationship
  from_relation_types_aggregate(
    # distinct select on columns
    distinct_on: [document_relation_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_relation_type_order_by!]

    # filter the rows returned
    where: document_relation_type_bool_exp
  ): document_relation_type_aggregate!

  # An array relationship connection
  from_relation_types_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_relation_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_relation_type_order_by!]

    # filter the rows returned
    where: document_relation_type_bool_exp
  ): document_relation_typeConnection!

  # An array relationship
  groups(
    # distinct select on columns
    distinct_on: [group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): [group!]!

  # An aggregated array relationship
  groups_aggregate(
    # distinct select on columns
    distinct_on: [group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): group_aggregate!

  # An array relationship connection
  groups_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [group_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): groupConnection!

  # An object relationship
  hierarchy: document_type_hierarchy
  hierarchy_id: uuid
  id: ID!
  name: String!

  # An object relationship
  sub_type_of: document_type
  sub_type_of_id: uuid

  # An array relationship
  sub_types(
    # distinct select on columns
    distinct_on: [document_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_type_order_by!]

    # filter the rows returned
    where: document_type_bool_exp
  ): [document_type!]!

  # An aggregated array relationship
  sub_types_aggregate(
    # distinct select on columns
    distinct_on: [document_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_type_order_by!]

    # filter the rows returned
    where: document_type_bool_exp
  ): document_type_aggregate!

  # An array relationship connection
  sub_types_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_order_by!]

    # filter the rows returned
    where: document_type_bool_exp
  ): document_typeConnection!

  # An array relationship
  to_relation_types(
    # distinct select on columns
    distinct_on: [document_relation_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_relation_type_order_by!]

    # filter the rows returned
    where: document_relation_type_bool_exp
  ): [document_relation_type!]!

  # An aggregated array relationship
  to_relation_types_aggregate(
    # distinct select on columns
    distinct_on: [document_relation_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_relation_type_order_by!]

    # filter the rows returned
    where: document_relation_type_bool_exp
  ): document_relation_type_aggregate!

  # An array relationship connection
  to_relation_types_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_relation_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_relation_type_order_by!]

    # filter the rows returned
    where: document_relation_type_bool_exp
  ): document_relation_typeConnection!
  updated_at: timestamptz

  # An object relationship
  workspace: workspace
  workspace_id: uuid!
}

# aggregated selection of "document_type"
type document_type_aggregate {
  aggregate: document_type_aggregate_fields
  nodes: [document_type!]!
}

# aggregate fields of "document_type"
type document_type_aggregate_fields {
  count(columns: [document_type_select_column!], distinct: Boolean): Int
  max: document_type_max_fields
  min: document_type_min_fields
}

# order by aggregate values of table "document_type"
input document_type_aggregate_order_by {
  count: order_by
  max: document_type_max_order_by
  min: document_type_min_order_by
}

# input type for inserting array relation for remote table "document_type"
input document_type_arr_rel_insert_input {
  data: [document_type_insert_input!]!
  on_conflict: document_type_on_conflict
}

# Boolean expression to filter rows from the table "document_type". All fields are combined with a logical 'AND'.
input document_type_bool_exp {
  _and: [document_type_bool_exp]
  _not: document_type_bool_exp
  _or: [document_type_bool_exp]
  children_hierarchy: document_type_hierarchy_bool_exp
  color: String_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  external_id: String_comparison_exp
  fields: document_type_document_field_bool_exp
  from_relation_types: document_relation_type_bool_exp
  groups: group_bool_exp
  hierarchy: document_type_hierarchy_bool_exp
  hierarchy_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sub_type_of: document_type_bool_exp
  sub_type_of_id: uuid_comparison_exp
  sub_types: document_type_bool_exp
  to_relation_types: document_relation_type_bool_exp
  updated_at: timestamptz_comparison_exp
  workspace: workspace_bool_exp
  workspace_id: uuid_comparison_exp
}

# unique or primary key constraints on table "document_type"
enum document_type_constraint {
  # unique or primary key constraint
  document_type_pkey
}

# columns and relationships of "document_type_document_field"
type document_type_document_field implements Node {
  # An object relationship
  field: field!
  field_id: uuid!
  id: ID!

  # An object relationship
  type: document_type!
  type_id: uuid!
}

# aggregated selection of "document_type_document_field"
type document_type_document_field_aggregate {
  aggregate: document_type_document_field_aggregate_fields
  nodes: [document_type_document_field!]!
}

# aggregate fields of "document_type_document_field"
type document_type_document_field_aggregate_fields {
  count(columns: [document_type_document_field_select_column!], distinct: Boolean): Int
  max: document_type_document_field_max_fields
  min: document_type_document_field_min_fields
}

# order by aggregate values of table "document_type_document_field"
input document_type_document_field_aggregate_order_by {
  count: order_by
  max: document_type_document_field_max_order_by
  min: document_type_document_field_min_order_by
}

# input type for inserting array relation for remote table "document_type_document_field"
input document_type_document_field_arr_rel_insert_input {
  data: [document_type_document_field_insert_input!]!
  on_conflict: document_type_document_field_on_conflict
}

# Boolean expression to filter rows from the table "document_type_document_field".
# All fields are combined with a logical 'AND'.
input document_type_document_field_bool_exp {
  _and: [document_type_document_field_bool_exp]
  _not: document_type_document_field_bool_exp
  _or: [document_type_document_field_bool_exp]
  field: field_bool_exp
  field_id: uuid_comparison_exp
  id: uuid_comparison_exp
  type: document_type_bool_exp
  type_id: uuid_comparison_exp
}

# unique or primary key constraints on table "document_type_document_field"
enum document_type_document_field_constraint {
  # unique or primary key constraint
  document_type_document_field_pkey
}

# input type for inserting data into table "document_type_document_field"
input document_type_document_field_insert_input {
  field: field_obj_rel_insert_input
  field_id: uuid
  id: uuid
  type: document_type_obj_rel_insert_input
  type_id: uuid
}

# aggregate max on columns
type document_type_document_field_max_fields {
  field_id: uuid
  id: uuid
  type_id: uuid
}

# order by max() on columns of table "document_type_document_field"
input document_type_document_field_max_order_by {
  field_id: order_by
  id: order_by
  type_id: order_by
}

# aggregate min on columns
type document_type_document_field_min_fields {
  field_id: uuid
  id: uuid
  type_id: uuid
}

# order by min() on columns of table "document_type_document_field"
input document_type_document_field_min_order_by {
  field_id: order_by
  id: order_by
  type_id: order_by
}

# response of any mutation on the table "document_type_document_field"
type document_type_document_field_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_type_document_field!]!
}

# input type for inserting object relation for remote table "document_type_document_field"
input document_type_document_field_obj_rel_insert_input {
  data: document_type_document_field_insert_input!
  on_conflict: document_type_document_field_on_conflict
}

# on conflict condition type for table "document_type_document_field"
input document_type_document_field_on_conflict {
  constraint: document_type_document_field_constraint!
  update_columns: [document_type_document_field_update_column!]!
  where: document_type_document_field_bool_exp
}

# ordering options when selecting data from "document_type_document_field"
input document_type_document_field_order_by {
  field: field_order_by
  field_id: order_by
  id: order_by
  type: document_type_order_by
  type_id: order_by
}

# primary key columns input for table: "document_type_document_field"
input document_type_document_field_pk_columns_input {
  id: uuid!
}

# select columns of table "document_type_document_field"
enum document_type_document_field_select_column {
  # column name
  field_id

  # column name
  id

  # column name
  type_id
}

# input type for updating data in table "document_type_document_field"
input document_type_document_field_set_input {
  field_id: uuid
  id: uuid
  type_id: uuid
}

# update columns of table "document_type_document_field"
enum document_type_document_field_update_column {
  # column name
  field_id

  # column name
  id

  # column name
  type_id
}

# A Relay Connection object on "document_type_document_field"
type document_type_document_fieldConnection {
  edges: [document_type_document_fieldEdge!]!
  pageInfo: PageInfo!
}

type document_type_document_fieldEdge {
  cursor: String!
  node: document_type_document_field!
}

# columns and relationships of "document_type_hierarchy"
type document_type_hierarchy implements Node {
  id: ID!

  # An object relationship
  parent: document_type!
  parent_id: uuid!
}

# aggregated selection of "document_type_hierarchy"
type document_type_hierarchy_aggregate {
  aggregate: document_type_hierarchy_aggregate_fields
  nodes: [document_type_hierarchy!]!
}

# aggregate fields of "document_type_hierarchy"
type document_type_hierarchy_aggregate_fields {
  count(columns: [document_type_hierarchy_select_column!], distinct: Boolean): Int
  max: document_type_hierarchy_max_fields
  min: document_type_hierarchy_min_fields
}

# order by aggregate values of table "document_type_hierarchy"
input document_type_hierarchy_aggregate_order_by {
  count: order_by
  max: document_type_hierarchy_max_order_by
  min: document_type_hierarchy_min_order_by
}

# input type for inserting array relation for remote table "document_type_hierarchy"
input document_type_hierarchy_arr_rel_insert_input {
  data: [document_type_hierarchy_insert_input!]!
  on_conflict: document_type_hierarchy_on_conflict
}

# Boolean expression to filter rows from the table "document_type_hierarchy". All fields are combined with a logical 'AND'.
input document_type_hierarchy_bool_exp {
  _and: [document_type_hierarchy_bool_exp]
  _not: document_type_hierarchy_bool_exp
  _or: [document_type_hierarchy_bool_exp]
  id: uuid_comparison_exp
  parent: document_type_bool_exp
  parent_id: uuid_comparison_exp
}

# unique or primary key constraints on table "document_type_hierarchy"
enum document_type_hierarchy_constraint {
  # unique or primary key constraint
  document_type_hierarchy_pkey
}

# input type for inserting data into table "document_type_hierarchy"
input document_type_hierarchy_insert_input {
  id: uuid
  parent: document_type_obj_rel_insert_input
  parent_id: uuid
}

# aggregate max on columns
type document_type_hierarchy_max_fields {
  id: uuid
  parent_id: uuid
}

# order by max() on columns of table "document_type_hierarchy"
input document_type_hierarchy_max_order_by {
  id: order_by
  parent_id: order_by
}

# aggregate min on columns
type document_type_hierarchy_min_fields {
  id: uuid
  parent_id: uuid
}

# order by min() on columns of table "document_type_hierarchy"
input document_type_hierarchy_min_order_by {
  id: order_by
  parent_id: order_by
}

# response of any mutation on the table "document_type_hierarchy"
type document_type_hierarchy_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_type_hierarchy!]!
}

# input type for inserting object relation for remote table "document_type_hierarchy"
input document_type_hierarchy_obj_rel_insert_input {
  data: document_type_hierarchy_insert_input!
  on_conflict: document_type_hierarchy_on_conflict
}

# on conflict condition type for table "document_type_hierarchy"
input document_type_hierarchy_on_conflict {
  constraint: document_type_hierarchy_constraint!
  update_columns: [document_type_hierarchy_update_column!]!
  where: document_type_hierarchy_bool_exp
}

# ordering options when selecting data from "document_type_hierarchy"
input document_type_hierarchy_order_by {
  id: order_by
  parent: document_type_order_by
  parent_id: order_by
}

# primary key columns input for table: "document_type_hierarchy"
input document_type_hierarchy_pk_columns_input {
  id: uuid!
}

# select columns of table "document_type_hierarchy"
enum document_type_hierarchy_select_column {
  # column name
  id

  # column name
  parent_id
}

# input type for updating data in table "document_type_hierarchy"
input document_type_hierarchy_set_input {
  id: uuid
  parent_id: uuid
}

# update columns of table "document_type_hierarchy"
enum document_type_hierarchy_update_column {
  # column name
  id

  # column name
  parent_id
}

# A Relay Connection object on "document_type_hierarchy"
type document_type_hierarchyConnection {
  edges: [document_type_hierarchyEdge!]!
  pageInfo: PageInfo!
}

type document_type_hierarchyEdge {
  cursor: String!
  node: document_type_hierarchy!
}

# input type for inserting data into table "document_type"
input document_type_insert_input {
  children_hierarchy: document_type_hierarchy_arr_rel_insert_input
  color: String
  created_at: timestamptz
  description: String
  external_id: String
  fields: document_type_document_field_arr_rel_insert_input
  from_relation_types: document_relation_type_arr_rel_insert_input
  groups: group_arr_rel_insert_input
  hierarchy: document_type_hierarchy_obj_rel_insert_input
  hierarchy_id: uuid
  id: uuid
  name: String
  sub_type_of: document_type_obj_rel_insert_input
  sub_type_of_id: uuid
  sub_types: document_type_arr_rel_insert_input
  to_relation_types: document_relation_type_arr_rel_insert_input
  updated_at: timestamptz
  workspace: workspace_obj_rel_insert_input
  workspace_id: uuid
}

# aggregate max on columns
type document_type_max_fields {
  color: String
  created_at: timestamptz
  description: String
  external_id: String
  hierarchy_id: uuid
  id: uuid
  name: String
  sub_type_of_id: uuid
  updated_at: timestamptz
  workspace_id: uuid
}

# order by max() on columns of table "document_type"
input document_type_max_order_by {
  color: order_by
  created_at: order_by
  description: order_by
  external_id: order_by
  hierarchy_id: order_by
  id: order_by
  name: order_by
  sub_type_of_id: order_by
  updated_at: order_by
  workspace_id: order_by
}

# aggregate min on columns
type document_type_min_fields {
  color: String
  created_at: timestamptz
  description: String
  external_id: String
  hierarchy_id: uuid
  id: uuid
  name: String
  sub_type_of_id: uuid
  updated_at: timestamptz
  workspace_id: uuid
}

# order by min() on columns of table "document_type"
input document_type_min_order_by {
  color: order_by
  created_at: order_by
  description: order_by
  external_id: order_by
  hierarchy_id: order_by
  id: order_by
  name: order_by
  sub_type_of_id: order_by
  updated_at: order_by
  workspace_id: order_by
}

# response of any mutation on the table "document_type"
type document_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_type!]!
}

# input type for inserting object relation for remote table "document_type"
input document_type_obj_rel_insert_input {
  data: document_type_insert_input!
  on_conflict: document_type_on_conflict
}

# on conflict condition type for table "document_type"
input document_type_on_conflict {
  constraint: document_type_constraint!
  update_columns: [document_type_update_column!]!
  where: document_type_bool_exp
}

# ordering options when selecting data from "document_type"
input document_type_order_by {
  children_hierarchy_aggregate: document_type_hierarchy_aggregate_order_by
  color: order_by
  created_at: order_by
  description: order_by
  external_id: order_by
  fields_aggregate: document_type_document_field_aggregate_order_by
  from_relation_types_aggregate: document_relation_type_aggregate_order_by
  groups_aggregate: group_aggregate_order_by
  hierarchy: document_type_hierarchy_order_by
  hierarchy_id: order_by
  id: order_by
  name: order_by
  sub_type_of: document_type_order_by
  sub_type_of_id: order_by
  sub_types_aggregate: document_type_aggregate_order_by
  to_relation_types_aggregate: document_relation_type_aggregate_order_by
  updated_at: order_by
  workspace: workspace_order_by
  workspace_id: order_by
}

# primary key columns input for table: "document_type"
input document_type_pk_columns_input {
  id: uuid!
}

# select columns of table "document_type"
enum document_type_select_column {
  # column name
  color

  # column name
  created_at

  # column name
  description

  # column name
  external_id

  # column name
  hierarchy_id

  # column name
  id

  # column name
  name

  # column name
  sub_type_of_id

  # column name
  updated_at

  # column name
  workspace_id
}

# input type for updating data in table "document_type"
input document_type_set_input {
  color: String
  created_at: timestamptz
  description: String
  external_id: String
  hierarchy_id: uuid
  id: uuid
  name: String
  sub_type_of_id: uuid
  updated_at: timestamptz
  workspace_id: uuid
}

# update columns of table "document_type"
enum document_type_update_column {
  # column name
  color

  # column name
  created_at

  # column name
  description

  # column name
  external_id

  # column name
  hierarchy_id

  # column name
  id

  # column name
  name

  # column name
  sub_type_of_id

  # column name
  updated_at

  # column name
  workspace_id
}

# A Relay Connection object on "document_type"
type document_typeConnection {
  edges: [document_typeEdge!]!
  pageInfo: PageInfo!
}

type document_typeEdge {
  cursor: String!
  node: document_type!
}

# update columns of table "document"
enum document_update_column {
  # column name
  created_at

  # column name
  description

  # column name
  external_id

  # column name
  id

  # column name
  name

  # column name
  parent_id

  # column name
  type_id

  # column name
  updated_at
}

# A Relay Connection object on "document"
type documentConnection {
  edges: [documentEdge!]!
  pageInfo: PageInfo!
}

type documentEdge {
  cursor: String!
  node: document!
}

# columns and relationships of "field"
type field implements Node {
  created_at: timestamptz
  description: String!
  external_id: String!

  # An object relationship
  field_type: field_type!
  field_type_id: uuid!

  # An array relationship
  field_values(
    # distinct select on columns
    distinct_on: [field_value_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [field_value_order_by!]

    # filter the rows returned
    where: field_value_bool_exp
  ): [field_value!]!

  # An aggregated array relationship
  field_values_aggregate(
    # distinct select on columns
    distinct_on: [field_value_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [field_value_order_by!]

    # filter the rows returned
    where: field_value_bool_exp
  ): field_value_aggregate!

  # An array relationship connection
  field_values_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [field_value_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [field_value_order_by!]

    # filter the rows returned
    where: field_value_bool_exp
  ): field_valueConnection!
  id: ID!
  mandatory: Boolean!
  name: String!
  order: Int!

  # An object relationship
  preview_info: preview_info

  # An array relationship
  types(
    # distinct select on columns
    distinct_on: [document_type_document_field_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_type_document_field_order_by!]

    # filter the rows returned
    where: document_type_document_field_bool_exp
  ): [document_type_document_field!]!

  # An aggregated array relationship
  types_aggregate(
    # distinct select on columns
    distinct_on: [document_type_document_field_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_type_document_field_order_by!]

    # filter the rows returned
    where: document_type_document_field_bool_exp
  ): document_type_document_field_aggregate!

  # An array relationship connection
  types_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_document_field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_document_field_order_by!]

    # filter the rows returned
    where: document_type_document_field_bool_exp
  ): document_type_document_fieldConnection!
  updated_at: timestamptz

  # An object relationship
  workspace: workspace!
  workspace_id: uuid!
}

# aggregated selection of "field"
type field_aggregate {
  aggregate: field_aggregate_fields
  nodes: [field!]!
}

# aggregate fields of "field"
type field_aggregate_fields {
  avg: field_avg_fields
  count(columns: [field_select_column!], distinct: Boolean): Int
  max: field_max_fields
  min: field_min_fields
  stddev: field_stddev_fields
  stddev_pop: field_stddev_pop_fields
  stddev_samp: field_stddev_samp_fields
  sum: field_sum_fields
  var_pop: field_var_pop_fields
  var_samp: field_var_samp_fields
  variance: field_variance_fields
}

# order by aggregate values of table "field"
input field_aggregate_order_by {
  avg: field_avg_order_by
  count: order_by
  max: field_max_order_by
  min: field_min_order_by
  stddev: field_stddev_order_by
  stddev_pop: field_stddev_pop_order_by
  stddev_samp: field_stddev_samp_order_by
  sum: field_sum_order_by
  var_pop: field_var_pop_order_by
  var_samp: field_var_samp_order_by
  variance: field_variance_order_by
}

# input type for inserting array relation for remote table "field"
input field_arr_rel_insert_input {
  data: [field_insert_input!]!
  on_conflict: field_on_conflict
}

# aggregate avg on columns
type field_avg_fields {
  order: Float
}

# order by avg() on columns of table "field"
input field_avg_order_by {
  order: order_by
}

# Boolean expression to filter rows from the table "field". All fields are combined with a logical 'AND'.
input field_bool_exp {
  _and: [field_bool_exp]
  _not: field_bool_exp
  _or: [field_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  external_id: String_comparison_exp
  field_type: field_type_bool_exp
  field_type_id: uuid_comparison_exp
  field_values: field_value_bool_exp
  id: uuid_comparison_exp
  mandatory: Boolean_comparison_exp
  name: String_comparison_exp
  order: Int_comparison_exp
  preview_info: preview_info_bool_exp
  types: document_type_document_field_bool_exp
  updated_at: timestamptz_comparison_exp
  workspace: workspace_bool_exp
  workspace_id: uuid_comparison_exp
}

# unique or primary key constraints on table "field"
enum field_constraint {
  # unique or primary key constraint
  document_field_pkey

  # unique or primary key constraint
  field_external_id_key
}

# input type for incrementing integer column in table "field"
input field_inc_input {
  order: Int
}

# input type for inserting data into table "field"
input field_insert_input {
  created_at: timestamptz
  description: String
  external_id: String
  field_type: field_type_obj_rel_insert_input
  field_type_id: uuid
  field_values: field_value_arr_rel_insert_input
  id: uuid
  mandatory: Boolean
  name: String
  order: Int
  preview_info: preview_info_obj_rel_insert_input
  types: document_type_document_field_arr_rel_insert_input
  updated_at: timestamptz
  workspace: workspace_obj_rel_insert_input
  workspace_id: uuid
}

# aggregate max on columns
type field_max_fields {
  created_at: timestamptz
  description: String
  external_id: String
  field_type_id: uuid
  id: uuid
  name: String
  order: Int
  updated_at: timestamptz
  workspace_id: uuid
}

# order by max() on columns of table "field"
input field_max_order_by {
  created_at: order_by
  description: order_by
  external_id: order_by
  field_type_id: order_by
  id: order_by
  name: order_by
  order: order_by
  updated_at: order_by
  workspace_id: order_by
}

# aggregate min on columns
type field_min_fields {
  created_at: timestamptz
  description: String
  external_id: String
  field_type_id: uuid
  id: uuid
  name: String
  order: Int
  updated_at: timestamptz
  workspace_id: uuid
}

# order by min() on columns of table "field"
input field_min_order_by {
  created_at: order_by
  description: order_by
  external_id: order_by
  field_type_id: order_by
  id: order_by
  name: order_by
  order: order_by
  updated_at: order_by
  workspace_id: order_by
}

# response of any mutation on the table "field"
type field_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [field!]!
}

# input type for inserting object relation for remote table "field"
input field_obj_rel_insert_input {
  data: field_insert_input!
  on_conflict: field_on_conflict
}

# on conflict condition type for table "field"
input field_on_conflict {
  constraint: field_constraint!
  update_columns: [field_update_column!]!
  where: field_bool_exp
}

# ordering options when selecting data from "field"
input field_order_by {
  created_at: order_by
  description: order_by
  external_id: order_by
  field_type: field_type_order_by
  field_type_id: order_by
  field_values_aggregate: field_value_aggregate_order_by
  id: order_by
  mandatory: order_by
  name: order_by
  order: order_by
  preview_info: preview_info_order_by
  types_aggregate: document_type_document_field_aggregate_order_by
  updated_at: order_by
  workspace: workspace_order_by
  workspace_id: order_by
}

# primary key columns input for table: "field"
input field_pk_columns_input {
  id: uuid!
}

# select columns of table "field"
enum field_select_column {
  # column name
  created_at

  # column name
  description

  # column name
  external_id

  # column name
  field_type_id

  # column name
  id

  # column name
  mandatory

  # column name
  name

  # column name
  order

  # column name
  updated_at

  # column name
  workspace_id
}

# input type for updating data in table "field"
input field_set_input {
  created_at: timestamptz
  description: String
  external_id: String
  field_type_id: uuid
  id: uuid
  mandatory: Boolean
  name: String
  order: Int
  updated_at: timestamptz
  workspace_id: uuid
}

# aggregate stddev on columns
type field_stddev_fields {
  order: Float
}

# order by stddev() on columns of table "field"
input field_stddev_order_by {
  order: order_by
}

# aggregate stddev_pop on columns
type field_stddev_pop_fields {
  order: Float
}

# order by stddev_pop() on columns of table "field"
input field_stddev_pop_order_by {
  order: order_by
}

# aggregate stddev_samp on columns
type field_stddev_samp_fields {
  order: Float
}

# order by stddev_samp() on columns of table "field"
input field_stddev_samp_order_by {
  order: order_by
}

# aggregate sum on columns
type field_sum_fields {
  order: Int
}

# order by sum() on columns of table "field"
input field_sum_order_by {
  order: order_by
}

# columns and relationships of "field_type"
type field_type implements Node {
  external_id: String!
  id: ID!
  metadata(
    # JSON select path
    path: String
  ): jsonb
  type: String!

  # An object relationship
  workspace: workspace
  workspace_id: uuid
}

# aggregated selection of "field_type"
type field_type_aggregate {
  aggregate: field_type_aggregate_fields
  nodes: [field_type!]!
}

# aggregate fields of "field_type"
type field_type_aggregate_fields {
  count(columns: [field_type_select_column!], distinct: Boolean): Int
  max: field_type_max_fields
  min: field_type_min_fields
}

# order by aggregate values of table "field_type"
input field_type_aggregate_order_by {
  count: order_by
  max: field_type_max_order_by
  min: field_type_min_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input field_type_append_input {
  metadata: jsonb
}

# input type for inserting array relation for remote table "field_type"
input field_type_arr_rel_insert_input {
  data: [field_type_insert_input!]!
  on_conflict: field_type_on_conflict
}

# Boolean expression to filter rows from the table "field_type". All fields are combined with a logical 'AND'.
input field_type_bool_exp {
  _and: [field_type_bool_exp]
  _not: field_type_bool_exp
  _or: [field_type_bool_exp]
  external_id: String_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  type: String_comparison_exp
  workspace: workspace_bool_exp
  workspace_id: uuid_comparison_exp
}

# unique or primary key constraints on table "field_type"
enum field_type_constraint {
  # unique or primary key constraint
  field_type_external_id_key

  # unique or primary key constraint
  field_type_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input field_type_delete_at_path_input {
  metadata: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input field_type_delete_elem_input {
  metadata: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input field_type_delete_key_input {
  metadata: String
}

# input type for inserting data into table "field_type"
input field_type_insert_input {
  external_id: String
  id: uuid
  metadata: jsonb
  type: String
  workspace: workspace_obj_rel_insert_input
  workspace_id: uuid
}

# aggregate max on columns
type field_type_max_fields {
  external_id: String
  id: uuid
  type: String
  workspace_id: uuid
}

# order by max() on columns of table "field_type"
input field_type_max_order_by {
  external_id: order_by
  id: order_by
  type: order_by
  workspace_id: order_by
}

# aggregate min on columns
type field_type_min_fields {
  external_id: String
  id: uuid
  type: String
  workspace_id: uuid
}

# order by min() on columns of table "field_type"
input field_type_min_order_by {
  external_id: order_by
  id: order_by
  type: order_by
  workspace_id: order_by
}

# response of any mutation on the table "field_type"
type field_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [field_type!]!
}

# input type for inserting object relation for remote table "field_type"
input field_type_obj_rel_insert_input {
  data: field_type_insert_input!
  on_conflict: field_type_on_conflict
}

# on conflict condition type for table "field_type"
input field_type_on_conflict {
  constraint: field_type_constraint!
  update_columns: [field_type_update_column!]!
  where: field_type_bool_exp
}

# ordering options when selecting data from "field_type"
input field_type_order_by {
  external_id: order_by
  id: order_by
  metadata: order_by
  type: order_by
  workspace: workspace_order_by
  workspace_id: order_by
}

# primary key columns input for table: "field_type"
input field_type_pk_columns_input {
  id: uuid!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input field_type_prepend_input {
  metadata: jsonb
}

# select columns of table "field_type"
enum field_type_select_column {
  # column name
  external_id

  # column name
  id

  # column name
  metadata

  # column name
  type

  # column name
  workspace_id
}

# input type for updating data in table "field_type"
input field_type_set_input {
  external_id: String
  id: uuid
  metadata: jsonb
  type: String
  workspace_id: uuid
}

# update columns of table "field_type"
enum field_type_update_column {
  # column name
  external_id

  # column name
  id

  # column name
  metadata

  # column name
  type

  # column name
  workspace_id
}

# A Relay Connection object on "field_type"
type field_typeConnection {
  edges: [field_typeEdge!]!
  pageInfo: PageInfo!
}

type field_typeEdge {
  cursor: String!
  node: field_type!
}

# update columns of table "field"
enum field_update_column {
  # column name
  created_at

  # column name
  description

  # column name
  external_id

  # column name
  field_type_id

  # column name
  id

  # column name
  mandatory

  # column name
  name

  # column name
  order

  # column name
  updated_at

  # column name
  workspace_id
}

# columns and relationships of "field_value"
type field_value implements Node {
  # An object relationship
  document: document
  document_id: uuid

  # An object relationship
  field: field
  field_id: uuid
  id: ID!
  value: String
}

# aggregated selection of "field_value"
type field_value_aggregate {
  aggregate: field_value_aggregate_fields
  nodes: [field_value!]!
}

# aggregate fields of "field_value"
type field_value_aggregate_fields {
  count(columns: [field_value_select_column!], distinct: Boolean): Int
  max: field_value_max_fields
  min: field_value_min_fields
}

# order by aggregate values of table "field_value"
input field_value_aggregate_order_by {
  count: order_by
  max: field_value_max_order_by
  min: field_value_min_order_by
}

# input type for inserting array relation for remote table "field_value"
input field_value_arr_rel_insert_input {
  data: [field_value_insert_input!]!
  on_conflict: field_value_on_conflict
}

# Boolean expression to filter rows from the table "field_value". All fields are combined with a logical 'AND'.
input field_value_bool_exp {
  _and: [field_value_bool_exp]
  _not: field_value_bool_exp
  _or: [field_value_bool_exp]
  document: document_bool_exp
  document_id: uuid_comparison_exp
  field: field_bool_exp
  field_id: uuid_comparison_exp
  id: uuid_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "field_value"
enum field_value_constraint {
  # unique or primary key constraint
  document_field_value_pkey

  # unique or primary key constraint
  document_field_values_field_id_document_id_key
}

# input type for inserting data into table "field_value"
input field_value_insert_input {
  document: document_obj_rel_insert_input
  document_id: uuid
  field: field_obj_rel_insert_input
  field_id: uuid
  id: uuid
  value: String
}

# aggregate max on columns
type field_value_max_fields {
  document_id: uuid
  field_id: uuid
  id: uuid
  value: String
}

# order by max() on columns of table "field_value"
input field_value_max_order_by {
  document_id: order_by
  field_id: order_by
  id: order_by
  value: order_by
}

# aggregate min on columns
type field_value_min_fields {
  document_id: uuid
  field_id: uuid
  id: uuid
  value: String
}

# order by min() on columns of table "field_value"
input field_value_min_order_by {
  document_id: order_by
  field_id: order_by
  id: order_by
  value: order_by
}

# response of any mutation on the table "field_value"
type field_value_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [field_value!]!
}

# input type for inserting object relation for remote table "field_value"
input field_value_obj_rel_insert_input {
  data: field_value_insert_input!
  on_conflict: field_value_on_conflict
}

# on conflict condition type for table "field_value"
input field_value_on_conflict {
  constraint: field_value_constraint!
  update_columns: [field_value_update_column!]!
  where: field_value_bool_exp
}

# ordering options when selecting data from "field_value"
input field_value_order_by {
  document: document_order_by
  document_id: order_by
  field: field_order_by
  field_id: order_by
  id: order_by
  value: order_by
}

# primary key columns input for table: "field_value"
input field_value_pk_columns_input {
  id: uuid!
}

# select columns of table "field_value"
enum field_value_select_column {
  # column name
  document_id

  # column name
  field_id

  # column name
  id

  # column name
  value
}

# input type for updating data in table "field_value"
input field_value_set_input {
  document_id: uuid
  field_id: uuid
  id: uuid
  value: String
}

# update columns of table "field_value"
enum field_value_update_column {
  # column name
  document_id

  # column name
  field_id

  # column name
  id

  # column name
  value
}

# A Relay Connection object on "field_value"
type field_valueConnection {
  edges: [field_valueEdge!]!
  pageInfo: PageInfo!
}

type field_valueEdge {
  cursor: String!
  node: field_value!
}

# aggregate var_pop on columns
type field_var_pop_fields {
  order: Float
}

# order by var_pop() on columns of table "field"
input field_var_pop_order_by {
  order: order_by
}

# aggregate var_samp on columns
type field_var_samp_fields {
  order: Float
}

# order by var_samp() on columns of table "field"
input field_var_samp_order_by {
  order: order_by
}

# aggregate variance on columns
type field_variance_fields {
  order: Float
}

# order by variance() on columns of table "field"
input field_variance_order_by {
  order: order_by
}

# A Relay Connection object on "field"
type fieldConnection {
  edges: [fieldEdge!]!
  pageInfo: PageInfo!
}

type fieldEdge {
  cursor: String!
  node: field!
}

# columns and relationships of "group"
type group implements Node {
  description: String!
  id: ID!
  name: String!

  # An array relationship
  relation_types(
    # distinct select on columns
    distinct_on: [group_relation_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_relation_type_order_by!]

    # filter the rows returned
    where: group_relation_type_bool_exp
  ): [group_relation_type!]!

  # An aggregated array relationship
  relation_types_aggregate(
    # distinct select on columns
    distinct_on: [group_relation_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [group_relation_type_order_by!]

    # filter the rows returned
    where: group_relation_type_bool_exp
  ): group_relation_type_aggregate!

  # An array relationship connection
  relation_types_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [group_relation_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [group_relation_type_order_by!]

    # filter the rows returned
    where: group_relation_type_bool_exp
  ): group_relation_typeConnection!

  # An array relationship
  sections(
    # distinct select on columns
    distinct_on: [section_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [section_order_by!]

    # filter the rows returned
    where: section_bool_exp
  ): [section!]!

  # An aggregated array relationship
  sections_aggregate(
    # distinct select on columns
    distinct_on: [section_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [section_order_by!]

    # filter the rows returned
    where: section_bool_exp
  ): section_aggregate!

  # An array relationship connection
  sections_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [section_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [section_order_by!]

    # filter the rows returned
    where: section_bool_exp
  ): sectionConnection!

  # An object relationship
  type: document_type
  type_id: uuid
}

# aggregated selection of "group"
type group_aggregate {
  aggregate: group_aggregate_fields
  nodes: [group!]!
}

# aggregate fields of "group"
type group_aggregate_fields {
  count(columns: [group_select_column!], distinct: Boolean): Int
  max: group_max_fields
  min: group_min_fields
}

# order by aggregate values of table "group"
input group_aggregate_order_by {
  count: order_by
  max: group_max_order_by
  min: group_min_order_by
}

# input type for inserting array relation for remote table "group"
input group_arr_rel_insert_input {
  data: [group_insert_input!]!
  on_conflict: group_on_conflict
}

# Boolean expression to filter rows from the table "group". All fields are combined with a logical 'AND'.
input group_bool_exp {
  _and: [group_bool_exp]
  _not: group_bool_exp
  _or: [group_bool_exp]
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  relation_types: group_relation_type_bool_exp
  sections: section_bool_exp
  type: document_type_bool_exp
  type_id: uuid_comparison_exp
}

# unique or primary key constraints on table "group"
enum group_constraint {
  # unique or primary key constraint
  document_field_group_pkey
}

# input type for inserting data into table "group"
input group_insert_input {
  description: String
  id: uuid
  name: String
  relation_types: group_relation_type_arr_rel_insert_input
  sections: section_arr_rel_insert_input
  type: document_type_obj_rel_insert_input
  type_id: uuid
}

# aggregate max on columns
type group_max_fields {
  description: String
  id: uuid
  name: String
  type_id: uuid
}

# order by max() on columns of table "group"
input group_max_order_by {
  description: order_by
  id: order_by
  name: order_by
  type_id: order_by
}

# aggregate min on columns
type group_min_fields {
  description: String
  id: uuid
  name: String
  type_id: uuid
}

# order by min() on columns of table "group"
input group_min_order_by {
  description: order_by
  id: order_by
  name: order_by
  type_id: order_by
}

# response of any mutation on the table "group"
type group_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [group!]!
}

# input type for inserting object relation for remote table "group"
input group_obj_rel_insert_input {
  data: group_insert_input!
  on_conflict: group_on_conflict
}

# on conflict condition type for table "group"
input group_on_conflict {
  constraint: group_constraint!
  update_columns: [group_update_column!]!
  where: group_bool_exp
}

# ordering options when selecting data from "group"
input group_order_by {
  description: order_by
  id: order_by
  name: order_by
  relation_types_aggregate: group_relation_type_aggregate_order_by
  sections_aggregate: section_aggregate_order_by
  type: document_type_order_by
  type_id: order_by
}

# primary key columns input for table: "group"
input group_pk_columns_input {
  id: uuid!
}

# columns and relationships of "group_relation_type"
type group_relation_type implements Node {
  # An object relationship
  group: group!
  group_id: uuid!
  id: ID!

  # An object relationship
  relation_type: document_relation_type!
  relation_type_id: uuid!
}

# aggregated selection of "group_relation_type"
type group_relation_type_aggregate {
  aggregate: group_relation_type_aggregate_fields
  nodes: [group_relation_type!]!
}

# aggregate fields of "group_relation_type"
type group_relation_type_aggregate_fields {
  count(columns: [group_relation_type_select_column!], distinct: Boolean): Int
  max: group_relation_type_max_fields
  min: group_relation_type_min_fields
}

# order by aggregate values of table "group_relation_type"
input group_relation_type_aggregate_order_by {
  count: order_by
  max: group_relation_type_max_order_by
  min: group_relation_type_min_order_by
}

# input type for inserting array relation for remote table "group_relation_type"
input group_relation_type_arr_rel_insert_input {
  data: [group_relation_type_insert_input!]!
  on_conflict: group_relation_type_on_conflict
}

# Boolean expression to filter rows from the table "group_relation_type". All fields are combined with a logical 'AND'.
input group_relation_type_bool_exp {
  _and: [group_relation_type_bool_exp]
  _not: group_relation_type_bool_exp
  _or: [group_relation_type_bool_exp]
  group: group_bool_exp
  group_id: uuid_comparison_exp
  id: uuid_comparison_exp
  relation_type: document_relation_type_bool_exp
  relation_type_id: uuid_comparison_exp
}

# unique or primary key constraints on table "group_relation_type"
enum group_relation_type_constraint {
  # unique or primary key constraint
  section_relation_type_pkey
}

# input type for inserting data into table "group_relation_type"
input group_relation_type_insert_input {
  group: group_obj_rel_insert_input
  group_id: uuid
  id: uuid
  relation_type: document_relation_type_obj_rel_insert_input
  relation_type_id: uuid
}

# aggregate max on columns
type group_relation_type_max_fields {
  group_id: uuid
  id: uuid
  relation_type_id: uuid
}

# order by max() on columns of table "group_relation_type"
input group_relation_type_max_order_by {
  group_id: order_by
  id: order_by
  relation_type_id: order_by
}

# aggregate min on columns
type group_relation_type_min_fields {
  group_id: uuid
  id: uuid
  relation_type_id: uuid
}

# order by min() on columns of table "group_relation_type"
input group_relation_type_min_order_by {
  group_id: order_by
  id: order_by
  relation_type_id: order_by
}

# response of any mutation on the table "group_relation_type"
type group_relation_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [group_relation_type!]!
}

# input type for inserting object relation for remote table "group_relation_type"
input group_relation_type_obj_rel_insert_input {
  data: group_relation_type_insert_input!
  on_conflict: group_relation_type_on_conflict
}

# on conflict condition type for table "group_relation_type"
input group_relation_type_on_conflict {
  constraint: group_relation_type_constraint!
  update_columns: [group_relation_type_update_column!]!
  where: group_relation_type_bool_exp
}

# ordering options when selecting data from "group_relation_type"
input group_relation_type_order_by {
  group: group_order_by
  group_id: order_by
  id: order_by
  relation_type: document_relation_type_order_by
  relation_type_id: order_by
}

# primary key columns input for table: "group_relation_type"
input group_relation_type_pk_columns_input {
  id: uuid!
}

# select columns of table "group_relation_type"
enum group_relation_type_select_column {
  # column name
  group_id

  # column name
  id

  # column name
  relation_type_id
}

# input type for updating data in table "group_relation_type"
input group_relation_type_set_input {
  group_id: uuid
  id: uuid
  relation_type_id: uuid
}

# update columns of table "group_relation_type"
enum group_relation_type_update_column {
  # column name
  group_id

  # column name
  id

  # column name
  relation_type_id
}

# A Relay Connection object on "group_relation_type"
type group_relation_typeConnection {
  edges: [group_relation_typeEdge!]!
  pageInfo: PageInfo!
}

type group_relation_typeEdge {
  cursor: String!
  node: group_relation_type!
}

# select columns of table "group"
enum group_select_column {
  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  type_id
}

# input type for updating data in table "group"
input group_set_input {
  description: String
  id: uuid
  name: String
  type_id: uuid
}

# update columns of table "group"
enum group_update_column {
  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  type_id
}

# A Relay Connection object on "group"
type groupConnection {
  edges: [groupEdge!]!
  pageInfo: PageInfo!
}

type groupEdge {
  cursor: String!
  node: group!
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar jsonb

# expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
input jsonb_comparison_exp {
  # is the column contained in the given json value
  _contained_in: jsonb

  # does the column contain the given json value at the top level
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  # does the string exist as a top-level key in the column
  _has_key: String

  # do all of these strings exist as top-level keys in the column
  _has_keys_all: [String!]

  # do any of these strings exist as top-level keys in the column
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

# mutation root
type mutation_root {
  # delete data from the table: "document"
  delete_document(
    # filter the rows which have to be deleted
    where: document_bool_exp!
  ): document_mutation_response

  # delete single row from the table: "document"
  delete_document_by_pk(id: uuid!): document

  # delete data from the table: "document_relation"
  delete_document_relation(
    # filter the rows which have to be deleted
    where: document_relation_bool_exp!
  ): document_relation_mutation_response

  # delete single row from the table: "document_relation"
  delete_document_relation_by_pk(id: uuid!): document_relation

  # delete data from the table: "document_relation_type"
  delete_document_relation_type(
    # filter the rows which have to be deleted
    where: document_relation_type_bool_exp!
  ): document_relation_type_mutation_response

  # delete single row from the table: "document_relation_type"
  delete_document_relation_type_by_pk(id: uuid!): document_relation_type

  # delete data from the table: "document_type"
  delete_document_type(
    # filter the rows which have to be deleted
    where: document_type_bool_exp!
  ): document_type_mutation_response

  # delete single row from the table: "document_type"
  delete_document_type_by_pk(id: uuid!): document_type

  # delete data from the table: "document_type_document_field"
  delete_document_type_document_field(
    # filter the rows which have to be deleted
    where: document_type_document_field_bool_exp!
  ): document_type_document_field_mutation_response

  # delete single row from the table: "document_type_document_field"
  delete_document_type_document_field_by_pk(id: uuid!): document_type_document_field

  # delete data from the table: "document_type_hierarchy"
  delete_document_type_hierarchy(
    # filter the rows which have to be deleted
    where: document_type_hierarchy_bool_exp!
  ): document_type_hierarchy_mutation_response

  # delete single row from the table: "document_type_hierarchy"
  delete_document_type_hierarchy_by_pk(id: uuid!): document_type_hierarchy

  # delete data from the table: "field"
  delete_field(
    # filter the rows which have to be deleted
    where: field_bool_exp!
  ): field_mutation_response

  # delete single row from the table: "field"
  delete_field_by_pk(id: uuid!): field

  # delete data from the table: "field_type"
  delete_field_type(
    # filter the rows which have to be deleted
    where: field_type_bool_exp!
  ): field_type_mutation_response

  # delete single row from the table: "field_type"
  delete_field_type_by_pk(id: uuid!): field_type

  # delete data from the table: "field_value"
  delete_field_value(
    # filter the rows which have to be deleted
    where: field_value_bool_exp!
  ): field_value_mutation_response

  # delete single row from the table: "field_value"
  delete_field_value_by_pk(id: uuid!): field_value

  # delete data from the table: "group"
  delete_group(
    # filter the rows which have to be deleted
    where: group_bool_exp!
  ): group_mutation_response

  # delete single row from the table: "group"
  delete_group_by_pk(id: uuid!): group

  # delete data from the table: "group_relation_type"
  delete_group_relation_type(
    # filter the rows which have to be deleted
    where: group_relation_type_bool_exp!
  ): group_relation_type_mutation_response

  # delete single row from the table: "group_relation_type"
  delete_group_relation_type_by_pk(id: uuid!): group_relation_type

  # delete data from the table: "preview_info"
  delete_preview_info(
    # filter the rows which have to be deleted
    where: preview_info_bool_exp!
  ): preview_info_mutation_response

  # delete single row from the table: "preview_info"
  delete_preview_info_by_pk(id: uuid!): preview_info

  # delete data from the table: "preview_info_type"
  delete_preview_info_type(
    # filter the rows which have to be deleted
    where: preview_info_type_bool_exp!
  ): preview_info_type_mutation_response

  # delete single row from the table: "preview_info_type"
  delete_preview_info_type_by_pk(name: String!): preview_info_type

  # delete data from the table: "recently_viewed_document"
  delete_recently_viewed_document(
    # filter the rows which have to be deleted
    where: recently_viewed_document_bool_exp!
  ): recently_viewed_document_mutation_response

  # delete single row from the table: "recently_viewed_document"
  delete_recently_viewed_document_by_pk(id: uuid!): recently_viewed_document

  # delete data from the table: "section"
  delete_section(
    # filter the rows which have to be deleted
    where: section_bool_exp!
  ): section_mutation_response

  # delete single row from the table: "section"
  delete_section_by_pk(id: uuid!): section

  # delete data from the table: "section_field"
  delete_section_field(
    # filter the rows which have to be deleted
    where: section_field_bool_exp!
  ): section_field_mutation_response

  # delete single row from the table: "section_field"
  delete_section_field_by_pk(id: uuid!): section_field

  # delete data from the table: "workspace"
  delete_workspace(
    # filter the rows which have to be deleted
    where: workspace_bool_exp!
  ): workspace_mutation_response

  # delete single row from the table: "workspace"
  delete_workspace_by_pk(id: uuid!): workspace

  # insert data into the table: "document"
  insert_document(
    # the rows to be inserted
    objects: [document_insert_input!]!

    # on conflict condition
    on_conflict: document_on_conflict
  ): document_mutation_response

  # insert a single row into the table: "document"
  insert_document_one(
    # the row to be inserted
    object: document_insert_input!

    # on conflict condition
    on_conflict: document_on_conflict
  ): document

  # insert data into the table: "document_relation"
  insert_document_relation(
    # the rows to be inserted
    objects: [document_relation_insert_input!]!

    # on conflict condition
    on_conflict: document_relation_on_conflict
  ): document_relation_mutation_response

  # insert a single row into the table: "document_relation"
  insert_document_relation_one(
    # the row to be inserted
    object: document_relation_insert_input!

    # on conflict condition
    on_conflict: document_relation_on_conflict
  ): document_relation

  # insert data into the table: "document_relation_type"
  insert_document_relation_type(
    # the rows to be inserted
    objects: [document_relation_type_insert_input!]!

    # on conflict condition
    on_conflict: document_relation_type_on_conflict
  ): document_relation_type_mutation_response

  # insert a single row into the table: "document_relation_type"
  insert_document_relation_type_one(
    # the row to be inserted
    object: document_relation_type_insert_input!

    # on conflict condition
    on_conflict: document_relation_type_on_conflict
  ): document_relation_type

  # insert data into the table: "document_type"
  insert_document_type(
    # the rows to be inserted
    objects: [document_type_insert_input!]!

    # on conflict condition
    on_conflict: document_type_on_conflict
  ): document_type_mutation_response

  # insert data into the table: "document_type_document_field"
  insert_document_type_document_field(
    # the rows to be inserted
    objects: [document_type_document_field_insert_input!]!

    # on conflict condition
    on_conflict: document_type_document_field_on_conflict
  ): document_type_document_field_mutation_response

  # insert a single row into the table: "document_type_document_field"
  insert_document_type_document_field_one(
    # the row to be inserted
    object: document_type_document_field_insert_input!

    # on conflict condition
    on_conflict: document_type_document_field_on_conflict
  ): document_type_document_field

  # insert data into the table: "document_type_hierarchy"
  insert_document_type_hierarchy(
    # the rows to be inserted
    objects: [document_type_hierarchy_insert_input!]!

    # on conflict condition
    on_conflict: document_type_hierarchy_on_conflict
  ): document_type_hierarchy_mutation_response

  # insert a single row into the table: "document_type_hierarchy"
  insert_document_type_hierarchy_one(
    # the row to be inserted
    object: document_type_hierarchy_insert_input!

    # on conflict condition
    on_conflict: document_type_hierarchy_on_conflict
  ): document_type_hierarchy

  # insert a single row into the table: "document_type"
  insert_document_type_one(
    # the row to be inserted
    object: document_type_insert_input!

    # on conflict condition
    on_conflict: document_type_on_conflict
  ): document_type

  # insert data into the table: "field"
  insert_field(
    # the rows to be inserted
    objects: [field_insert_input!]!

    # on conflict condition
    on_conflict: field_on_conflict
  ): field_mutation_response

  # insert a single row into the table: "field"
  insert_field_one(
    # the row to be inserted
    object: field_insert_input!

    # on conflict condition
    on_conflict: field_on_conflict
  ): field

  # insert data into the table: "field_type"
  insert_field_type(
    # the rows to be inserted
    objects: [field_type_insert_input!]!

    # on conflict condition
    on_conflict: field_type_on_conflict
  ): field_type_mutation_response

  # insert a single row into the table: "field_type"
  insert_field_type_one(
    # the row to be inserted
    object: field_type_insert_input!

    # on conflict condition
    on_conflict: field_type_on_conflict
  ): field_type

  # insert data into the table: "field_value"
  insert_field_value(
    # the rows to be inserted
    objects: [field_value_insert_input!]!

    # on conflict condition
    on_conflict: field_value_on_conflict
  ): field_value_mutation_response

  # insert a single row into the table: "field_value"
  insert_field_value_one(
    # the row to be inserted
    object: field_value_insert_input!

    # on conflict condition
    on_conflict: field_value_on_conflict
  ): field_value

  # insert data into the table: "group"
  insert_group(
    # the rows to be inserted
    objects: [group_insert_input!]!

    # on conflict condition
    on_conflict: group_on_conflict
  ): group_mutation_response

  # insert a single row into the table: "group"
  insert_group_one(
    # the row to be inserted
    object: group_insert_input!

    # on conflict condition
    on_conflict: group_on_conflict
  ): group

  # insert data into the table: "group_relation_type"
  insert_group_relation_type(
    # the rows to be inserted
    objects: [group_relation_type_insert_input!]!

    # on conflict condition
    on_conflict: group_relation_type_on_conflict
  ): group_relation_type_mutation_response

  # insert a single row into the table: "group_relation_type"
  insert_group_relation_type_one(
    # the row to be inserted
    object: group_relation_type_insert_input!

    # on conflict condition
    on_conflict: group_relation_type_on_conflict
  ): group_relation_type

  # insert data into the table: "preview_info"
  insert_preview_info(
    # the rows to be inserted
    objects: [preview_info_insert_input!]!

    # on conflict condition
    on_conflict: preview_info_on_conflict
  ): preview_info_mutation_response

  # insert a single row into the table: "preview_info"
  insert_preview_info_one(
    # the row to be inserted
    object: preview_info_insert_input!

    # on conflict condition
    on_conflict: preview_info_on_conflict
  ): preview_info

  # insert data into the table: "preview_info_type"
  insert_preview_info_type(
    # the rows to be inserted
    objects: [preview_info_type_insert_input!]!

    # on conflict condition
    on_conflict: preview_info_type_on_conflict
  ): preview_info_type_mutation_response

  # insert a single row into the table: "preview_info_type"
  insert_preview_info_type_one(
    # the row to be inserted
    object: preview_info_type_insert_input!

    # on conflict condition
    on_conflict: preview_info_type_on_conflict
  ): preview_info_type

  # insert data into the table: "recently_viewed_document"
  insert_recently_viewed_document(
    # the rows to be inserted
    objects: [recently_viewed_document_insert_input!]!

    # on conflict condition
    on_conflict: recently_viewed_document_on_conflict
  ): recently_viewed_document_mutation_response

  # insert a single row into the table: "recently_viewed_document"
  insert_recently_viewed_document_one(
    # the row to be inserted
    object: recently_viewed_document_insert_input!

    # on conflict condition
    on_conflict: recently_viewed_document_on_conflict
  ): recently_viewed_document

  # insert data into the table: "section"
  insert_section(
    # the rows to be inserted
    objects: [section_insert_input!]!

    # on conflict condition
    on_conflict: section_on_conflict
  ): section_mutation_response

  # insert data into the table: "section_field"
  insert_section_field(
    # the rows to be inserted
    objects: [section_field_insert_input!]!

    # on conflict condition
    on_conflict: section_field_on_conflict
  ): section_field_mutation_response

  # insert a single row into the table: "section_field"
  insert_section_field_one(
    # the row to be inserted
    object: section_field_insert_input!

    # on conflict condition
    on_conflict: section_field_on_conflict
  ): section_field

  # insert a single row into the table: "section"
  insert_section_one(
    # the row to be inserted
    object: section_insert_input!

    # on conflict condition
    on_conflict: section_on_conflict
  ): section

  # insert data into the table: "workspace"
  insert_workspace(
    # the rows to be inserted
    objects: [workspace_insert_input!]!

    # on conflict condition
    on_conflict: workspace_on_conflict
  ): workspace_mutation_response

  # insert a single row into the table: "workspace"
  insert_workspace_one(
    # the row to be inserted
    object: workspace_insert_input!

    # on conflict condition
    on_conflict: workspace_on_conflict
  ): workspace

  # update data of the table: "document"
  update_document(
    # sets the columns of the filtered rows to the given values
    _set: document_set_input

    # filter the rows which have to be updated
    where: document_bool_exp!
  ): document_mutation_response

  # update single row of the table: "document"
  update_document_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_set_input
    pk_columns: document_pk_columns_input!
  ): document

  # update data of the table: "document_relation"
  update_document_relation(
    # sets the columns of the filtered rows to the given values
    _set: document_relation_set_input

    # filter the rows which have to be updated
    where: document_relation_bool_exp!
  ): document_relation_mutation_response

  # update single row of the table: "document_relation"
  update_document_relation_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_relation_set_input
    pk_columns: document_relation_pk_columns_input!
  ): document_relation

  # update data of the table: "document_relation_type"
  update_document_relation_type(
    # sets the columns of the filtered rows to the given values
    _set: document_relation_type_set_input

    # filter the rows which have to be updated
    where: document_relation_type_bool_exp!
  ): document_relation_type_mutation_response

  # update single row of the table: "document_relation_type"
  update_document_relation_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_relation_type_set_input
    pk_columns: document_relation_type_pk_columns_input!
  ): document_relation_type

  # update data of the table: "document_type"
  update_document_type(
    # sets the columns of the filtered rows to the given values
    _set: document_type_set_input

    # filter the rows which have to be updated
    where: document_type_bool_exp!
  ): document_type_mutation_response

  # update single row of the table: "document_type"
  update_document_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_type_set_input
    pk_columns: document_type_pk_columns_input!
  ): document_type

  # update data of the table: "document_type_document_field"
  update_document_type_document_field(
    # sets the columns of the filtered rows to the given values
    _set: document_type_document_field_set_input

    # filter the rows which have to be updated
    where: document_type_document_field_bool_exp!
  ): document_type_document_field_mutation_response

  # update single row of the table: "document_type_document_field"
  update_document_type_document_field_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_type_document_field_set_input
    pk_columns: document_type_document_field_pk_columns_input!
  ): document_type_document_field

  # update data of the table: "document_type_hierarchy"
  update_document_type_hierarchy(
    # sets the columns of the filtered rows to the given values
    _set: document_type_hierarchy_set_input

    # filter the rows which have to be updated
    where: document_type_hierarchy_bool_exp!
  ): document_type_hierarchy_mutation_response

  # update single row of the table: "document_type_hierarchy"
  update_document_type_hierarchy_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_type_hierarchy_set_input
    pk_columns: document_type_hierarchy_pk_columns_input!
  ): document_type_hierarchy

  # update data of the table: "field"
  update_field(
    # increments the integer columns with given value of the filtered values
    _inc: field_inc_input

    # sets the columns of the filtered rows to the given values
    _set: field_set_input

    # filter the rows which have to be updated
    where: field_bool_exp!
  ): field_mutation_response

  # update single row of the table: "field"
  update_field_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: field_inc_input

    # sets the columns of the filtered rows to the given values
    _set: field_set_input
    pk_columns: field_pk_columns_input!
  ): field

  # update data of the table: "field_type"
  update_field_type(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: field_type_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: field_type_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: field_type_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: field_type_delete_key_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: field_type_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: field_type_set_input

    # filter the rows which have to be updated
    where: field_type_bool_exp!
  ): field_type_mutation_response

  # update single row of the table: "field_type"
  update_field_type_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: field_type_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: field_type_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: field_type_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: field_type_delete_key_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: field_type_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: field_type_set_input
    pk_columns: field_type_pk_columns_input!
  ): field_type

  # update data of the table: "field_value"
  update_field_value(
    # sets the columns of the filtered rows to the given values
    _set: field_value_set_input

    # filter the rows which have to be updated
    where: field_value_bool_exp!
  ): field_value_mutation_response

  # update single row of the table: "field_value"
  update_field_value_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: field_value_set_input
    pk_columns: field_value_pk_columns_input!
  ): field_value

  # update data of the table: "group"
  update_group(
    # sets the columns of the filtered rows to the given values
    _set: group_set_input

    # filter the rows which have to be updated
    where: group_bool_exp!
  ): group_mutation_response

  # update single row of the table: "group"
  update_group_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: group_set_input
    pk_columns: group_pk_columns_input!
  ): group

  # update data of the table: "group_relation_type"
  update_group_relation_type(
    # sets the columns of the filtered rows to the given values
    _set: group_relation_type_set_input

    # filter the rows which have to be updated
    where: group_relation_type_bool_exp!
  ): group_relation_type_mutation_response

  # update single row of the table: "group_relation_type"
  update_group_relation_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: group_relation_type_set_input
    pk_columns: group_relation_type_pk_columns_input!
  ): group_relation_type

  # update data of the table: "preview_info"
  update_preview_info(
    # sets the columns of the filtered rows to the given values
    _set: preview_info_set_input

    # filter the rows which have to be updated
    where: preview_info_bool_exp!
  ): preview_info_mutation_response

  # update single row of the table: "preview_info"
  update_preview_info_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: preview_info_set_input
    pk_columns: preview_info_pk_columns_input!
  ): preview_info

  # update data of the table: "preview_info_type"
  update_preview_info_type(
    # sets the columns of the filtered rows to the given values
    _set: preview_info_type_set_input

    # filter the rows which have to be updated
    where: preview_info_type_bool_exp!
  ): preview_info_type_mutation_response

  # update single row of the table: "preview_info_type"
  update_preview_info_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: preview_info_type_set_input
    pk_columns: preview_info_type_pk_columns_input!
  ): preview_info_type

  # update data of the table: "recently_viewed_document"
  update_recently_viewed_document(
    # sets the columns of the filtered rows to the given values
    _set: recently_viewed_document_set_input

    # filter the rows which have to be updated
    where: recently_viewed_document_bool_exp!
  ): recently_viewed_document_mutation_response

  # update single row of the table: "recently_viewed_document"
  update_recently_viewed_document_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: recently_viewed_document_set_input
    pk_columns: recently_viewed_document_pk_columns_input!
  ): recently_viewed_document

  # update data of the table: "section"
  update_section(
    # sets the columns of the filtered rows to the given values
    _set: section_set_input

    # filter the rows which have to be updated
    where: section_bool_exp!
  ): section_mutation_response

  # update single row of the table: "section"
  update_section_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: section_set_input
    pk_columns: section_pk_columns_input!
  ): section

  # update data of the table: "section_field"
  update_section_field(
    # sets the columns of the filtered rows to the given values
    _set: section_field_set_input

    # filter the rows which have to be updated
    where: section_field_bool_exp!
  ): section_field_mutation_response

  # update single row of the table: "section_field"
  update_section_field_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: section_field_set_input
    pk_columns: section_field_pk_columns_input!
  ): section_field

  # update data of the table: "workspace"
  update_workspace(
    # sets the columns of the filtered rows to the given values
    _set: workspace_set_input

    # filter the rows which have to be updated
    where: workspace_bool_exp!
  ): workspace_mutation_response

  # update single row of the table: "workspace"
  update_workspace_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: workspace_set_input
    pk_columns: workspace_pk_columns_input!
  ): workspace
}

# An object with globally unique ID
interface Node {
  # A globally unique identifier
  id: ID!
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

# columns and relationships of "preview_info"
type preview_info implements Node {
  created_at: timestamptz!

  # An object relationship
  field: field!
  field_id: uuid!
  id: ID!
  show: Boolean!
  type: preview_info_type_enum!
  updated_at: timestamptz!
}

# aggregated selection of "preview_info"
type preview_info_aggregate {
  aggregate: preview_info_aggregate_fields
  nodes: [preview_info!]!
}

# aggregate fields of "preview_info"
type preview_info_aggregate_fields {
  count(columns: [preview_info_select_column!], distinct: Boolean): Int
  max: preview_info_max_fields
  min: preview_info_min_fields
}

# order by aggregate values of table "preview_info"
input preview_info_aggregate_order_by {
  count: order_by
  max: preview_info_max_order_by
  min: preview_info_min_order_by
}

# input type for inserting array relation for remote table "preview_info"
input preview_info_arr_rel_insert_input {
  data: [preview_info_insert_input!]!
  on_conflict: preview_info_on_conflict
}

# Boolean expression to filter rows from the table "preview_info". All fields are combined with a logical 'AND'.
input preview_info_bool_exp {
  _and: [preview_info_bool_exp]
  _not: preview_info_bool_exp
  _or: [preview_info_bool_exp]
  created_at: timestamptz_comparison_exp
  field: field_bool_exp
  field_id: uuid_comparison_exp
  id: uuid_comparison_exp
  show: Boolean_comparison_exp
  type: preview_info_type_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "preview_info"
enum preview_info_constraint {
  # unique or primary key constraint
  preview_info_field_id_key

  # unique or primary key constraint
  preview_info_pkey
}

# input type for inserting data into table "preview_info"
input preview_info_insert_input {
  created_at: timestamptz
  field: field_obj_rel_insert_input
  field_id: uuid
  id: uuid
  show: Boolean
  type: preview_info_type_enum
  updated_at: timestamptz
}

# aggregate max on columns
type preview_info_max_fields {
  created_at: timestamptz
  field_id: uuid
  id: uuid
  updated_at: timestamptz
}

# order by max() on columns of table "preview_info"
input preview_info_max_order_by {
  created_at: order_by
  field_id: order_by
  id: order_by
  updated_at: order_by
}

# aggregate min on columns
type preview_info_min_fields {
  created_at: timestamptz
  field_id: uuid
  id: uuid
  updated_at: timestamptz
}

# order by min() on columns of table "preview_info"
input preview_info_min_order_by {
  created_at: order_by
  field_id: order_by
  id: order_by
  updated_at: order_by
}

# response of any mutation on the table "preview_info"
type preview_info_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [preview_info!]!
}

# input type for inserting object relation for remote table "preview_info"
input preview_info_obj_rel_insert_input {
  data: preview_info_insert_input!
  on_conflict: preview_info_on_conflict
}

# on conflict condition type for table "preview_info"
input preview_info_on_conflict {
  constraint: preview_info_constraint!
  update_columns: [preview_info_update_column!]!
  where: preview_info_bool_exp
}

# ordering options when selecting data from "preview_info"
input preview_info_order_by {
  created_at: order_by
  field: field_order_by
  field_id: order_by
  id: order_by
  show: order_by
  type: order_by
  updated_at: order_by
}

# primary key columns input for table: "preview_info"
input preview_info_pk_columns_input {
  id: uuid!
}

# select columns of table "preview_info"
enum preview_info_select_column {
  # column name
  created_at

  # column name
  field_id

  # column name
  id

  # column name
  show

  # column name
  type

  # column name
  updated_at
}

# input type for updating data in table "preview_info"
input preview_info_set_input {
  created_at: timestamptz
  field_id: uuid
  id: uuid
  show: Boolean
  type: preview_info_type_enum
  updated_at: timestamptz
}

# columns and relationships of "preview_info_type"
type preview_info_type implements Node {
  id: ID!
  name: String!
}

# aggregated selection of "preview_info_type"
type preview_info_type_aggregate {
  aggregate: preview_info_type_aggregate_fields
  nodes: [preview_info_type!]!
}

# aggregate fields of "preview_info_type"
type preview_info_type_aggregate_fields {
  count(columns: [preview_info_type_select_column!], distinct: Boolean): Int
  max: preview_info_type_max_fields
  min: preview_info_type_min_fields
}

# order by aggregate values of table "preview_info_type"
input preview_info_type_aggregate_order_by {
  count: order_by
  max: preview_info_type_max_order_by
  min: preview_info_type_min_order_by
}

# input type for inserting array relation for remote table "preview_info_type"
input preview_info_type_arr_rel_insert_input {
  data: [preview_info_type_insert_input!]!
  on_conflict: preview_info_type_on_conflict
}

# Boolean expression to filter rows from the table "preview_info_type". All fields are combined with a logical 'AND'.
input preview_info_type_bool_exp {
  _and: [preview_info_type_bool_exp]
  _not: preview_info_type_bool_exp
  _or: [preview_info_type_bool_exp]
  name: String_comparison_exp
}

# unique or primary key constraints on table "preview_info_type"
enum preview_info_type_constraint {
  # unique or primary key constraint
  preview_info_type_pkey
}

enum preview_info_type_enum {
  badge
  label
}

# expression to compare columns of type preview_info_type_enum. All fields are combined with logical 'AND'.
input preview_info_type_enum_comparison_exp {
  _eq: preview_info_type_enum
  _in: [preview_info_type_enum!]
  _is_null: Boolean
  _neq: preview_info_type_enum
  _nin: [preview_info_type_enum!]
}

# input type for inserting data into table "preview_info_type"
input preview_info_type_insert_input {
  name: String
}

# aggregate max on columns
type preview_info_type_max_fields {
  name: String
}

# order by max() on columns of table "preview_info_type"
input preview_info_type_max_order_by {
  name: order_by
}

# aggregate min on columns
type preview_info_type_min_fields {
  name: String
}

# order by min() on columns of table "preview_info_type"
input preview_info_type_min_order_by {
  name: order_by
}

# response of any mutation on the table "preview_info_type"
type preview_info_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [preview_info_type!]!
}

# input type for inserting object relation for remote table "preview_info_type"
input preview_info_type_obj_rel_insert_input {
  data: preview_info_type_insert_input!
  on_conflict: preview_info_type_on_conflict
}

# on conflict condition type for table "preview_info_type"
input preview_info_type_on_conflict {
  constraint: preview_info_type_constraint!
  update_columns: [preview_info_type_update_column!]!
  where: preview_info_type_bool_exp
}

# ordering options when selecting data from "preview_info_type"
input preview_info_type_order_by {
  name: order_by
}

# primary key columns input for table: "preview_info_type"
input preview_info_type_pk_columns_input {
  name: String!
}

# select columns of table "preview_info_type"
enum preview_info_type_select_column {
  # column name
  name
}

# input type for updating data in table "preview_info_type"
input preview_info_type_set_input {
  name: String
}

# update columns of table "preview_info_type"
enum preview_info_type_update_column {
  # column name
  name
}

# A Relay Connection object on "preview_info_type"
type preview_info_typeConnection {
  edges: [preview_info_typeEdge!]!
  pageInfo: PageInfo!
}

type preview_info_typeEdge {
  cursor: String!
  node: preview_info_type!
}

# update columns of table "preview_info"
enum preview_info_update_column {
  # column name
  created_at

  # column name
  field_id

  # column name
  id

  # column name
  show

  # column name
  type

  # column name
  updated_at
}

# A Relay Connection object on "preview_info"
type preview_infoConnection {
  edges: [preview_infoEdge!]!
  pageInfo: PageInfo!
}

type preview_infoEdge {
  cursor: String!
  node: preview_info!
}

# query root
type query_root {
  # fetch data from the table: "document"
  document_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_order_by!]

    # filter the rows returned
    where: document_bool_exp
  ): documentConnection!

  # fetch data from the table: "document_relation"
  document_relation_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_relation_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_relation_order_by!]

    # filter the rows returned
    where: document_relation_bool_exp
  ): document_relationConnection!

  # fetch data from the table: "document_relation_type"
  document_relation_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_relation_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_relation_type_order_by!]

    # filter the rows returned
    where: document_relation_type_bool_exp
  ): document_relation_typeConnection!

  # fetch data from the table: "document_type"
  document_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_order_by!]

    # filter the rows returned
    where: document_type_bool_exp
  ): document_typeConnection!

  # fetch data from the table: "document_type_document_field"
  document_type_document_field_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_document_field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_document_field_order_by!]

    # filter the rows returned
    where: document_type_document_field_bool_exp
  ): document_type_document_fieldConnection!

  # fetch data from the table: "document_type_hierarchy"
  document_type_hierarchy_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_hierarchy_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_hierarchy_order_by!]

    # filter the rows returned
    where: document_type_hierarchy_bool_exp
  ): document_type_hierarchyConnection!

  # fetch data from the table: "field"
  field_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [field_order_by!]

    # filter the rows returned
    where: field_bool_exp
  ): fieldConnection!

  # fetch data from the table: "field_type"
  field_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [field_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [field_type_order_by!]

    # filter the rows returned
    where: field_type_bool_exp
  ): field_typeConnection!

  # fetch data from the table: "field_value"
  field_value_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [field_value_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [field_value_order_by!]

    # filter the rows returned
    where: field_value_bool_exp
  ): field_valueConnection!

  # fetch data from the table: "group"
  group_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [group_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): groupConnection!

  # fetch data from the table: "group_relation_type"
  group_relation_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [group_relation_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [group_relation_type_order_by!]

    # filter the rows returned
    where: group_relation_type_bool_exp
  ): group_relation_typeConnection!
  node(
    # A globally unique id
    id: ID!
  ): Node

  # fetch data from the table: "preview_info"
  preview_info_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [preview_info_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [preview_info_order_by!]

    # filter the rows returned
    where: preview_info_bool_exp
  ): preview_infoConnection!

  # fetch data from the table: "preview_info_type"
  preview_info_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [preview_info_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [preview_info_type_order_by!]

    # filter the rows returned
    where: preview_info_type_bool_exp
  ): preview_info_typeConnection!

  # fetch data from the table: "recently_viewed_document"
  recently_viewed_document_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [recently_viewed_document_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [recently_viewed_document_order_by!]

    # filter the rows returned
    where: recently_viewed_document_bool_exp
  ): recently_viewed_documentConnection!

  # fetch data from the table: "section"
  section_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [section_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [section_order_by!]

    # filter the rows returned
    where: section_bool_exp
  ): sectionConnection!

  # fetch data from the table: "section_field"
  section_field_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [section_field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [section_field_order_by!]

    # filter the rows returned
    where: section_field_bool_exp
  ): section_fieldConnection!

  # fetch data from the table: "workspace"
  workspace_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [workspace_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [workspace_order_by!]

    # filter the rows returned
    where: workspace_bool_exp
  ): workspaceConnection!
}

# columns and relationships of "recently_viewed_document"
type recently_viewed_document implements Node {
  # An object relationship
  document: document!
  document_id: uuid!
  id: ID!
  timestamp: timestamptz!
  user_id: uuid!
  workspace_id: uuid!
}

# aggregated selection of "recently_viewed_document"
type recently_viewed_document_aggregate {
  aggregate: recently_viewed_document_aggregate_fields
  nodes: [recently_viewed_document!]!
}

# aggregate fields of "recently_viewed_document"
type recently_viewed_document_aggregate_fields {
  count(columns: [recently_viewed_document_select_column!], distinct: Boolean): Int
  max: recently_viewed_document_max_fields
  min: recently_viewed_document_min_fields
}

# order by aggregate values of table "recently_viewed_document"
input recently_viewed_document_aggregate_order_by {
  count: order_by
  max: recently_viewed_document_max_order_by
  min: recently_viewed_document_min_order_by
}

# input type for inserting array relation for remote table "recently_viewed_document"
input recently_viewed_document_arr_rel_insert_input {
  data: [recently_viewed_document_insert_input!]!
  on_conflict: recently_viewed_document_on_conflict
}

# Boolean expression to filter rows from the table "recently_viewed_document". All fields are combined with a logical 'AND'.
input recently_viewed_document_bool_exp {
  _and: [recently_viewed_document_bool_exp]
  _not: recently_viewed_document_bool_exp
  _or: [recently_viewed_document_bool_exp]
  document: document_bool_exp
  document_id: uuid_comparison_exp
  id: uuid_comparison_exp
  timestamp: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
  workspace_id: uuid_comparison_exp
}

# unique or primary key constraints on table "recently_viewed_document"
enum recently_viewed_document_constraint {
  # unique or primary key constraint
  recently_viewed_document_pkey
}

# input type for inserting data into table "recently_viewed_document"
input recently_viewed_document_insert_input {
  document: document_obj_rel_insert_input
  document_id: uuid
  id: uuid
  timestamp: timestamptz
  user_id: uuid
  workspace_id: uuid
}

# aggregate max on columns
type recently_viewed_document_max_fields {
  document_id: uuid
  id: uuid
  timestamp: timestamptz
  user_id: uuid
  workspace_id: uuid
}

# order by max() on columns of table "recently_viewed_document"
input recently_viewed_document_max_order_by {
  document_id: order_by
  id: order_by
  timestamp: order_by
  user_id: order_by
  workspace_id: order_by
}

# aggregate min on columns
type recently_viewed_document_min_fields {
  document_id: uuid
  id: uuid
  timestamp: timestamptz
  user_id: uuid
  workspace_id: uuid
}

# order by min() on columns of table "recently_viewed_document"
input recently_viewed_document_min_order_by {
  document_id: order_by
  id: order_by
  timestamp: order_by
  user_id: order_by
  workspace_id: order_by
}

# response of any mutation on the table "recently_viewed_document"
type recently_viewed_document_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [recently_viewed_document!]!
}

# input type for inserting object relation for remote table "recently_viewed_document"
input recently_viewed_document_obj_rel_insert_input {
  data: recently_viewed_document_insert_input!
  on_conflict: recently_viewed_document_on_conflict
}

# on conflict condition type for table "recently_viewed_document"
input recently_viewed_document_on_conflict {
  constraint: recently_viewed_document_constraint!
  update_columns: [recently_viewed_document_update_column!]!
  where: recently_viewed_document_bool_exp
}

# ordering options when selecting data from "recently_viewed_document"
input recently_viewed_document_order_by {
  document: document_order_by
  document_id: order_by
  id: order_by
  timestamp: order_by
  user_id: order_by
  workspace_id: order_by
}

# primary key columns input for table: "recently_viewed_document"
input recently_viewed_document_pk_columns_input {
  id: uuid!
}

# select columns of table "recently_viewed_document"
enum recently_viewed_document_select_column {
  # column name
  document_id

  # column name
  id

  # column name
  timestamp

  # column name
  user_id

  # column name
  workspace_id
}

# input type for updating data in table "recently_viewed_document"
input recently_viewed_document_set_input {
  document_id: uuid
  id: uuid
  timestamp: timestamptz
  user_id: uuid
  workspace_id: uuid
}

# update columns of table "recently_viewed_document"
enum recently_viewed_document_update_column {
  # column name
  document_id

  # column name
  id

  # column name
  timestamp

  # column name
  user_id

  # column name
  workspace_id
}

# A Relay Connection object on "recently_viewed_document"
type recently_viewed_documentConnection {
  edges: [recently_viewed_documentEdge!]!
  pageInfo: PageInfo!
}

type recently_viewed_documentEdge {
  cursor: String!
  node: recently_viewed_document!
}

# columns and relationships of "section"
type section implements Node {
  description: String!

  # An array relationship
  fields(
    # distinct select on columns
    distinct_on: [section_field_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [section_field_order_by!]

    # filter the rows returned
    where: section_field_bool_exp
  ): [section_field!]!

  # An aggregated array relationship
  fields_aggregate(
    # distinct select on columns
    distinct_on: [section_field_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [section_field_order_by!]

    # filter the rows returned
    where: section_field_bool_exp
  ): section_field_aggregate!

  # An array relationship connection
  fields_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [section_field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [section_field_order_by!]

    # filter the rows returned
    where: section_field_bool_exp
  ): section_fieldConnection!

  # An object relationship
  group: group!
  group_id: uuid!
  id: ID!
  name: String!
}

# aggregated selection of "section"
type section_aggregate {
  aggregate: section_aggregate_fields
  nodes: [section!]!
}

# aggregate fields of "section"
type section_aggregate_fields {
  count(columns: [section_select_column!], distinct: Boolean): Int
  max: section_max_fields
  min: section_min_fields
}

# order by aggregate values of table "section"
input section_aggregate_order_by {
  count: order_by
  max: section_max_order_by
  min: section_min_order_by
}

# input type for inserting array relation for remote table "section"
input section_arr_rel_insert_input {
  data: [section_insert_input!]!
  on_conflict: section_on_conflict
}

# Boolean expression to filter rows from the table "section". All fields are combined with a logical 'AND'.
input section_bool_exp {
  _and: [section_bool_exp]
  _not: section_bool_exp
  _or: [section_bool_exp]
  description: String_comparison_exp
  fields: section_field_bool_exp
  group: group_bool_exp
  group_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "section"
enum section_constraint {
  # unique or primary key constraint
  document_field_section_pkey
}

# columns and relationships of "section_field"
type section_field implements Node {
  # An object relationship
  field: field!
  field_id: uuid!
  id: ID!

  # An object relationship
  section: section!
  section_id: uuid!
}

# aggregated selection of "section_field"
type section_field_aggregate {
  aggregate: section_field_aggregate_fields
  nodes: [section_field!]!
}

# aggregate fields of "section_field"
type section_field_aggregate_fields {
  count(columns: [section_field_select_column!], distinct: Boolean): Int
  max: section_field_max_fields
  min: section_field_min_fields
}

# order by aggregate values of table "section_field"
input section_field_aggregate_order_by {
  count: order_by
  max: section_field_max_order_by
  min: section_field_min_order_by
}

# input type for inserting array relation for remote table "section_field"
input section_field_arr_rel_insert_input {
  data: [section_field_insert_input!]!
  on_conflict: section_field_on_conflict
}

# Boolean expression to filter rows from the table "section_field". All fields are combined with a logical 'AND'.
input section_field_bool_exp {
  _and: [section_field_bool_exp]
  _not: section_field_bool_exp
  _or: [section_field_bool_exp]
  field: field_bool_exp
  field_id: uuid_comparison_exp
  id: uuid_comparison_exp
  section: section_bool_exp
  section_id: uuid_comparison_exp
}

# unique or primary key constraints on table "section_field"
enum section_field_constraint {
  # unique or primary key constraint
  field_section_pkey
}

# input type for inserting data into table "section_field"
input section_field_insert_input {
  field: field_obj_rel_insert_input
  field_id: uuid
  id: uuid
  section: section_obj_rel_insert_input
  section_id: uuid
}

# aggregate max on columns
type section_field_max_fields {
  field_id: uuid
  id: uuid
  section_id: uuid
}

# order by max() on columns of table "section_field"
input section_field_max_order_by {
  field_id: order_by
  id: order_by
  section_id: order_by
}

# aggregate min on columns
type section_field_min_fields {
  field_id: uuid
  id: uuid
  section_id: uuid
}

# order by min() on columns of table "section_field"
input section_field_min_order_by {
  field_id: order_by
  id: order_by
  section_id: order_by
}

# response of any mutation on the table "section_field"
type section_field_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [section_field!]!
}

# input type for inserting object relation for remote table "section_field"
input section_field_obj_rel_insert_input {
  data: section_field_insert_input!
  on_conflict: section_field_on_conflict
}

# on conflict condition type for table "section_field"
input section_field_on_conflict {
  constraint: section_field_constraint!
  update_columns: [section_field_update_column!]!
  where: section_field_bool_exp
}

# ordering options when selecting data from "section_field"
input section_field_order_by {
  field: field_order_by
  field_id: order_by
  id: order_by
  section: section_order_by
  section_id: order_by
}

# primary key columns input for table: "section_field"
input section_field_pk_columns_input {
  id: uuid!
}

# select columns of table "section_field"
enum section_field_select_column {
  # column name
  field_id

  # column name
  id

  # column name
  section_id
}

# input type for updating data in table "section_field"
input section_field_set_input {
  field_id: uuid
  id: uuid
  section_id: uuid
}

# update columns of table "section_field"
enum section_field_update_column {
  # column name
  field_id

  # column name
  id

  # column name
  section_id
}

# A Relay Connection object on "section_field"
type section_fieldConnection {
  edges: [section_fieldEdge!]!
  pageInfo: PageInfo!
}

type section_fieldEdge {
  cursor: String!
  node: section_field!
}

# input type for inserting data into table "section"
input section_insert_input {
  description: String
  fields: section_field_arr_rel_insert_input
  group: group_obj_rel_insert_input
  group_id: uuid
  id: uuid
  name: String
}

# aggregate max on columns
type section_max_fields {
  description: String
  group_id: uuid
  id: uuid
  name: String
}

# order by max() on columns of table "section"
input section_max_order_by {
  description: order_by
  group_id: order_by
  id: order_by
  name: order_by
}

# aggregate min on columns
type section_min_fields {
  description: String
  group_id: uuid
  id: uuid
  name: String
}

# order by min() on columns of table "section"
input section_min_order_by {
  description: order_by
  group_id: order_by
  id: order_by
  name: order_by
}

# response of any mutation on the table "section"
type section_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [section!]!
}

# input type for inserting object relation for remote table "section"
input section_obj_rel_insert_input {
  data: section_insert_input!
  on_conflict: section_on_conflict
}

# on conflict condition type for table "section"
input section_on_conflict {
  constraint: section_constraint!
  update_columns: [section_update_column!]!
  where: section_bool_exp
}

# ordering options when selecting data from "section"
input section_order_by {
  description: order_by
  fields_aggregate: section_field_aggregate_order_by
  group: group_order_by
  group_id: order_by
  id: order_by
  name: order_by
}

# primary key columns input for table: "section"
input section_pk_columns_input {
  id: uuid!
}

# select columns of table "section"
enum section_select_column {
  # column name
  description

  # column name
  group_id

  # column name
  id

  # column name
  name
}

# input type for updating data in table "section"
input section_set_input {
  description: String
  group_id: uuid
  id: uuid
  name: String
}

# update columns of table "section"
enum section_update_column {
  # column name
  description

  # column name
  group_id

  # column name
  id

  # column name
  name
}

# A Relay Connection object on "section"
type sectionConnection {
  edges: [sectionEdge!]!
  pageInfo: PageInfo!
}

type sectionEdge {
  cursor: String!
  node: section!
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "document"
  document_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_order_by!]

    # filter the rows returned
    where: document_bool_exp
  ): documentConnection!

  # fetch data from the table: "document_relation"
  document_relation_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_relation_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_relation_order_by!]

    # filter the rows returned
    where: document_relation_bool_exp
  ): document_relationConnection!

  # fetch data from the table: "document_relation_type"
  document_relation_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_relation_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_relation_type_order_by!]

    # filter the rows returned
    where: document_relation_type_bool_exp
  ): document_relation_typeConnection!

  # fetch data from the table: "document_type"
  document_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_order_by!]

    # filter the rows returned
    where: document_type_bool_exp
  ): document_typeConnection!

  # fetch data from the table: "document_type_document_field"
  document_type_document_field_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_document_field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_document_field_order_by!]

    # filter the rows returned
    where: document_type_document_field_bool_exp
  ): document_type_document_fieldConnection!

  # fetch data from the table: "document_type_hierarchy"
  document_type_hierarchy_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_hierarchy_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_hierarchy_order_by!]

    # filter the rows returned
    where: document_type_hierarchy_bool_exp
  ): document_type_hierarchyConnection!

  # fetch data from the table: "field"
  field_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [field_order_by!]

    # filter the rows returned
    where: field_bool_exp
  ): fieldConnection!

  # fetch data from the table: "field_type"
  field_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [field_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [field_type_order_by!]

    # filter the rows returned
    where: field_type_bool_exp
  ): field_typeConnection!

  # fetch data from the table: "field_value"
  field_value_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [field_value_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [field_value_order_by!]

    # filter the rows returned
    where: field_value_bool_exp
  ): field_valueConnection!

  # fetch data from the table: "group"
  group_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [group_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [group_order_by!]

    # filter the rows returned
    where: group_bool_exp
  ): groupConnection!

  # fetch data from the table: "group_relation_type"
  group_relation_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [group_relation_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [group_relation_type_order_by!]

    # filter the rows returned
    where: group_relation_type_bool_exp
  ): group_relation_typeConnection!
  node(
    # A globally unique id
    id: ID!
  ): Node

  # fetch data from the table: "preview_info"
  preview_info_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [preview_info_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [preview_info_order_by!]

    # filter the rows returned
    where: preview_info_bool_exp
  ): preview_infoConnection!

  # fetch data from the table: "preview_info_type"
  preview_info_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [preview_info_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [preview_info_type_order_by!]

    # filter the rows returned
    where: preview_info_type_bool_exp
  ): preview_info_typeConnection!

  # fetch data from the table: "recently_viewed_document"
  recently_viewed_document_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [recently_viewed_document_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [recently_viewed_document_order_by!]

    # filter the rows returned
    where: recently_viewed_document_bool_exp
  ): recently_viewed_documentConnection!

  # fetch data from the table: "section"
  section_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [section_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [section_order_by!]

    # filter the rows returned
    where: section_bool_exp
  ): sectionConnection!

  # fetch data from the table: "section_field"
  section_field_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [section_field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [section_field_order_by!]

    # filter the rows returned
    where: section_field_bool_exp
  ): section_fieldConnection!

  # fetch data from the table: "workspace"
  workspace_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [workspace_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [workspace_order_by!]

    # filter the rows returned
    where: workspace_bool_exp
  ): workspaceConnection!
}

scalar timestamptz

# expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar uuid

# expression to compare columns of type uuid. All fields are combined with logical 'AND'.
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

# columns and relationships of "workspace"
type workspace implements Node {
  active: Boolean
  created_at: timestamptz
  id: ID!
  name: String!
  updated_at: timestamptz
}

# aggregated selection of "workspace"
type workspace_aggregate {
  aggregate: workspace_aggregate_fields
  nodes: [workspace!]!
}

# aggregate fields of "workspace"
type workspace_aggregate_fields {
  count(columns: [workspace_select_column!], distinct: Boolean): Int
  max: workspace_max_fields
  min: workspace_min_fields
}

# order by aggregate values of table "workspace"
input workspace_aggregate_order_by {
  count: order_by
  max: workspace_max_order_by
  min: workspace_min_order_by
}

# input type for inserting array relation for remote table "workspace"
input workspace_arr_rel_insert_input {
  data: [workspace_insert_input!]!
  on_conflict: workspace_on_conflict
}

# Boolean expression to filter rows from the table "workspace". All fields are combined with a logical 'AND'.
input workspace_bool_exp {
  _and: [workspace_bool_exp]
  _not: workspace_bool_exp
  _or: [workspace_bool_exp]
  active: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "workspace"
enum workspace_constraint {
  # unique or primary key constraint
  workspaces_name_key

  # unique or primary key constraint
  workspaces_pkey
}

# input type for inserting data into table "workspace"
input workspace_insert_input {
  active: Boolean
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

# aggregate max on columns
type workspace_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

# order by max() on columns of table "workspace"
input workspace_max_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# aggregate min on columns
type workspace_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

# order by min() on columns of table "workspace"
input workspace_min_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# response of any mutation on the table "workspace"
type workspace_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [workspace!]!
}

# input type for inserting object relation for remote table "workspace"
input workspace_obj_rel_insert_input {
  data: workspace_insert_input!
  on_conflict: workspace_on_conflict
}

# on conflict condition type for table "workspace"
input workspace_on_conflict {
  constraint: workspace_constraint!
  update_columns: [workspace_update_column!]!
  where: workspace_bool_exp
}

# ordering options when selecting data from "workspace"
input workspace_order_by {
  active: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# primary key columns input for table: "workspace"
input workspace_pk_columns_input {
  id: uuid!
}

# select columns of table "workspace"
enum workspace_select_column {
  # column name
  active

  # column name
  created_at

  # column name
  id

  # column name
  name

  # column name
  updated_at
}

# input type for updating data in table "workspace"
input workspace_set_input {
  active: Boolean
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

# update columns of table "workspace"
enum workspace_update_column {
  # column name
  active

  # column name
  created_at

  # column name
  id

  # column name
  name

  # column name
  updated_at
}

# A Relay Connection object on "workspace"
type workspaceConnection {
  edges: [workspaceEdge!]!
  pageInfo: PageInfo!
}

type workspaceEdge {
  cursor: String!
  node: workspace!
}

