schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# columns and relationships of "document"
type document implements Node {
  created_at: timestamptz
  description: String!
  external_id: String

  # An array relationship
  field_values(
    # distinct select on columns
    distinct_on: [document_field_value_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_value_order_by!]

    # filter the rows returned
    where: document_field_value_bool_exp
  ): [document_field_value!]!

  # An aggregated array relationship
  field_values_aggregate(
    # distinct select on columns
    distinct_on: [document_field_value_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_value_order_by!]

    # filter the rows returned
    where: document_field_value_bool_exp
  ): document_field_value_aggregate!

  # An array relationship connection
  field_values_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_value_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_value_order_by!]

    # filter the rows returned
    where: document_field_value_bool_exp
  ): document_field_valueConnection!
  id: ID!
  name: String!

  # An object relationship
  type: document_type
  type_id: uuid!
  updated_at: timestamptz
}

# aggregated selection of "document"
type document_aggregate {
  aggregate: document_aggregate_fields
  nodes: [document!]!
}

# aggregate fields of "document"
type document_aggregate_fields {
  count(columns: [document_select_column!], distinct: Boolean): Int
  max: document_max_fields
  min: document_min_fields
}

# order by aggregate values of table "document"
input document_aggregate_order_by {
  count: order_by
  max: document_max_order_by
  min: document_min_order_by
}

# input type for inserting array relation for remote table "document"
input document_arr_rel_insert_input {
  data: [document_insert_input!]!
  on_conflict: document_on_conflict
}

# Boolean expression to filter rows from the table "document". All fields are combined with a logical 'AND'.
input document_bool_exp {
  _and: [document_bool_exp]
  _not: document_bool_exp
  _or: [document_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  external_id: String_comparison_exp
  field_values: document_field_value_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  type: document_type_bool_exp
  type_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "document"
enum document_constraint {
  # unique or primary key constraint
  document_pkey
}

# columns and relationships of "document_field"
type document_field implements Node {
  created_at: timestamptz
  description: String!

  # An object relationship
  document_type: document_type
  document_type_id: uuid!
  external_id: String!
  field_type: String!

  # An array relationship
  field_values(
    # distinct select on columns
    distinct_on: [document_field_value_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_value_order_by!]

    # filter the rows returned
    where: document_field_value_bool_exp
  ): [document_field_value!]!

  # An aggregated array relationship
  field_values_aggregate(
    # distinct select on columns
    distinct_on: [document_field_value_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_value_order_by!]

    # filter the rows returned
    where: document_field_value_bool_exp
  ): document_field_value_aggregate!

  # An array relationship connection
  field_values_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_value_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_value_order_by!]

    # filter the rows returned
    where: document_field_value_bool_exp
  ): document_field_valueConnection!
  id: ID!
  mandatory: Boolean!
  name: String!
  order: Int!

  # An object relationship
  preview_info: preview_info

  # An object relationship
  section: document_field_section
  section_id: uuid
  updated_at: timestamptz
}

# aggregated selection of "document_field"
type document_field_aggregate {
  aggregate: document_field_aggregate_fields
  nodes: [document_field!]!
}

# aggregate fields of "document_field"
type document_field_aggregate_fields {
  avg: document_field_avg_fields
  count(columns: [document_field_select_column!], distinct: Boolean): Int
  max: document_field_max_fields
  min: document_field_min_fields
  stddev: document_field_stddev_fields
  stddev_pop: document_field_stddev_pop_fields
  stddev_samp: document_field_stddev_samp_fields
  sum: document_field_sum_fields
  var_pop: document_field_var_pop_fields
  var_samp: document_field_var_samp_fields
  variance: document_field_variance_fields
}

# order by aggregate values of table "document_field"
input document_field_aggregate_order_by {
  avg: document_field_avg_order_by
  count: order_by
  max: document_field_max_order_by
  min: document_field_min_order_by
  stddev: document_field_stddev_order_by
  stddev_pop: document_field_stddev_pop_order_by
  stddev_samp: document_field_stddev_samp_order_by
  sum: document_field_sum_order_by
  var_pop: document_field_var_pop_order_by
  var_samp: document_field_var_samp_order_by
  variance: document_field_variance_order_by
}

# input type for inserting array relation for remote table "document_field"
input document_field_arr_rel_insert_input {
  data: [document_field_insert_input!]!
  on_conflict: document_field_on_conflict
}

# aggregate avg on columns
type document_field_avg_fields {
  order: Float
}

# order by avg() on columns of table "document_field"
input document_field_avg_order_by {
  order: order_by
}

# Boolean expression to filter rows from the table "document_field". All fields are combined with a logical 'AND'.
input document_field_bool_exp {
  _and: [document_field_bool_exp]
  _not: document_field_bool_exp
  _or: [document_field_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  document_type: document_type_bool_exp
  document_type_id: uuid_comparison_exp
  external_id: String_comparison_exp
  field_type: String_comparison_exp
  field_values: document_field_value_bool_exp
  id: uuid_comparison_exp
  mandatory: Boolean_comparison_exp
  name: String_comparison_exp
  order: Int_comparison_exp
  preview_info: preview_info_bool_exp
  section: document_field_section_bool_exp
  section_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "document_field"
enum document_field_constraint {
  # unique or primary key constraint
  document_field_pkey
}

# columns and relationships of "document_field_group"
type document_field_group implements Node {
  description: String!
  id: ID!
  name: String!

  # An array relationship
  sections(
    # distinct select on columns
    distinct_on: [document_field_section_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_section_order_by!]

    # filter the rows returned
    where: document_field_section_bool_exp
  ): [document_field_section!]!

  # An aggregated array relationship
  sections_aggregate(
    # distinct select on columns
    distinct_on: [document_field_section_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_section_order_by!]

    # filter the rows returned
    where: document_field_section_bool_exp
  ): document_field_section_aggregate!

  # An array relationship connection
  sections_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_section_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_section_order_by!]

    # filter the rows returned
    where: document_field_section_bool_exp
  ): document_field_sectionConnection!

  # An object relationship
  type: document_type
  type_id: uuid
}

# aggregated selection of "document_field_group"
type document_field_group_aggregate {
  aggregate: document_field_group_aggregate_fields
  nodes: [document_field_group!]!
}

# aggregate fields of "document_field_group"
type document_field_group_aggregate_fields {
  count(columns: [document_field_group_select_column!], distinct: Boolean): Int
  max: document_field_group_max_fields
  min: document_field_group_min_fields
}

# order by aggregate values of table "document_field_group"
input document_field_group_aggregate_order_by {
  count: order_by
  max: document_field_group_max_order_by
  min: document_field_group_min_order_by
}

# input type for inserting array relation for remote table "document_field_group"
input document_field_group_arr_rel_insert_input {
  data: [document_field_group_insert_input!]!
  on_conflict: document_field_group_on_conflict
}

# Boolean expression to filter rows from the table "document_field_group". All fields are combined with a logical 'AND'.
input document_field_group_bool_exp {
  _and: [document_field_group_bool_exp]
  _not: document_field_group_bool_exp
  _or: [document_field_group_bool_exp]
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sections: document_field_section_bool_exp
  type: document_type_bool_exp
  type_id: uuid_comparison_exp
}

# unique or primary key constraints on table "document_field_group"
enum document_field_group_constraint {
  # unique or primary key constraint
  document_field_group_pkey
}

# input type for inserting data into table "document_field_group"
input document_field_group_insert_input {
  description: String
  id: uuid
  name: String
  sections: document_field_section_arr_rel_insert_input
  type: document_type_obj_rel_insert_input
  type_id: uuid
}

# aggregate max on columns
type document_field_group_max_fields {
  description: String
  id: uuid
  name: String
  type_id: uuid
}

# order by max() on columns of table "document_field_group"
input document_field_group_max_order_by {
  description: order_by
  id: order_by
  name: order_by
  type_id: order_by
}

# aggregate min on columns
type document_field_group_min_fields {
  description: String
  id: uuid
  name: String
  type_id: uuid
}

# order by min() on columns of table "document_field_group"
input document_field_group_min_order_by {
  description: order_by
  id: order_by
  name: order_by
  type_id: order_by
}

# response of any mutation on the table "document_field_group"
type document_field_group_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_field_group!]!
}

# input type for inserting object relation for remote table "document_field_group"
input document_field_group_obj_rel_insert_input {
  data: document_field_group_insert_input!
  on_conflict: document_field_group_on_conflict
}

# on conflict condition type for table "document_field_group"
input document_field_group_on_conflict {
  constraint: document_field_group_constraint!
  update_columns: [document_field_group_update_column!]!
  where: document_field_group_bool_exp
}

# ordering options when selecting data from "document_field_group"
input document_field_group_order_by {
  description: order_by
  id: order_by
  name: order_by
  sections_aggregate: document_field_section_aggregate_order_by
  type: document_type_order_by
  type_id: order_by
}

# primary key columns input for table: "document_field_group"
input document_field_group_pk_columns_input {
  id: uuid!
}

# select columns of table "document_field_group"
enum document_field_group_select_column {
  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  type_id
}

# input type for updating data in table "document_field_group"
input document_field_group_set_input {
  description: String
  id: uuid
  name: String
  type_id: uuid
}

# update columns of table "document_field_group"
enum document_field_group_update_column {
  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  type_id
}

# A Relay Connection object on "document_field_group"
type document_field_groupConnection {
  edges: [document_field_groupEdge!]!
  pageInfo: PageInfo!
}

type document_field_groupEdge {
  cursor: String!
  node: document_field_group!
}

# input type for incrementing integer column in table "document_field"
input document_field_inc_input {
  order: Int
}

# input type for inserting data into table "document_field"
input document_field_insert_input {
  created_at: timestamptz
  description: String
  document_type: document_type_obj_rel_insert_input
  document_type_id: uuid
  external_id: String
  field_type: String
  field_values: document_field_value_arr_rel_insert_input
  id: uuid
  mandatory: Boolean
  name: String
  order: Int
  preview_info: preview_info_obj_rel_insert_input
  section: document_field_section_obj_rel_insert_input
  section_id: uuid
  updated_at: timestamptz
}

# aggregate max on columns
type document_field_max_fields {
  created_at: timestamptz
  description: String
  document_type_id: uuid
  external_id: String
  field_type: String
  id: uuid
  name: String
  order: Int
  section_id: uuid
  updated_at: timestamptz
}

# order by max() on columns of table "document_field"
input document_field_max_order_by {
  created_at: order_by
  description: order_by
  document_type_id: order_by
  external_id: order_by
  field_type: order_by
  id: order_by
  name: order_by
  order: order_by
  section_id: order_by
  updated_at: order_by
}

# aggregate min on columns
type document_field_min_fields {
  created_at: timestamptz
  description: String
  document_type_id: uuid
  external_id: String
  field_type: String
  id: uuid
  name: String
  order: Int
  section_id: uuid
  updated_at: timestamptz
}

# order by min() on columns of table "document_field"
input document_field_min_order_by {
  created_at: order_by
  description: order_by
  document_type_id: order_by
  external_id: order_by
  field_type: order_by
  id: order_by
  name: order_by
  order: order_by
  section_id: order_by
  updated_at: order_by
}

# response of any mutation on the table "document_field"
type document_field_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_field!]!
}

# input type for inserting object relation for remote table "document_field"
input document_field_obj_rel_insert_input {
  data: document_field_insert_input!
  on_conflict: document_field_on_conflict
}

# on conflict condition type for table "document_field"
input document_field_on_conflict {
  constraint: document_field_constraint!
  update_columns: [document_field_update_column!]!
  where: document_field_bool_exp
}

# ordering options when selecting data from "document_field"
input document_field_order_by {
  created_at: order_by
  description: order_by
  document_type: document_type_order_by
  document_type_id: order_by
  external_id: order_by
  field_type: order_by
  field_values_aggregate: document_field_value_aggregate_order_by
  id: order_by
  mandatory: order_by
  name: order_by
  order: order_by
  preview_info: preview_info_order_by
  section: document_field_section_order_by
  section_id: order_by
  updated_at: order_by
}

# primary key columns input for table: "document_field"
input document_field_pk_columns_input {
  id: uuid!
}

# columns and relationships of "document_field_section"
type document_field_section implements Node {
  description: String!

  # An array relationship
  fields(
    # distinct select on columns
    distinct_on: [document_field_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_order_by!]

    # filter the rows returned
    where: document_field_bool_exp
  ): [document_field!]!

  # An aggregated array relationship
  fields_aggregate(
    # distinct select on columns
    distinct_on: [document_field_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_order_by!]

    # filter the rows returned
    where: document_field_bool_exp
  ): document_field_aggregate!

  # An array relationship connection
  fields_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_order_by!]

    # filter the rows returned
    where: document_field_bool_exp
  ): document_fieldConnection!

  # An object relationship
  group: document_field_group!
  group_id: uuid!
  id: ID!
  name: String!
}

# aggregated selection of "document_field_section"
type document_field_section_aggregate {
  aggregate: document_field_section_aggregate_fields
  nodes: [document_field_section!]!
}

# aggregate fields of "document_field_section"
type document_field_section_aggregate_fields {
  count(columns: [document_field_section_select_column!], distinct: Boolean): Int
  max: document_field_section_max_fields
  min: document_field_section_min_fields
}

# order by aggregate values of table "document_field_section"
input document_field_section_aggregate_order_by {
  count: order_by
  max: document_field_section_max_order_by
  min: document_field_section_min_order_by
}

# input type for inserting array relation for remote table "document_field_section"
input document_field_section_arr_rel_insert_input {
  data: [document_field_section_insert_input!]!
  on_conflict: document_field_section_on_conflict
}

# Boolean expression to filter rows from the table "document_field_section". All fields are combined with a logical 'AND'.
input document_field_section_bool_exp {
  _and: [document_field_section_bool_exp]
  _not: document_field_section_bool_exp
  _or: [document_field_section_bool_exp]
  description: String_comparison_exp
  fields: document_field_bool_exp
  group: document_field_group_bool_exp
  group_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "document_field_section"
enum document_field_section_constraint {
  # unique or primary key constraint
  document_field_section_pkey
}

# input type for inserting data into table "document_field_section"
input document_field_section_insert_input {
  description: String
  fields: document_field_arr_rel_insert_input
  group: document_field_group_obj_rel_insert_input
  group_id: uuid
  id: uuid
  name: String
}

# aggregate max on columns
type document_field_section_max_fields {
  description: String
  group_id: uuid
  id: uuid
  name: String
}

# order by max() on columns of table "document_field_section"
input document_field_section_max_order_by {
  description: order_by
  group_id: order_by
  id: order_by
  name: order_by
}

# aggregate min on columns
type document_field_section_min_fields {
  description: String
  group_id: uuid
  id: uuid
  name: String
}

# order by min() on columns of table "document_field_section"
input document_field_section_min_order_by {
  description: order_by
  group_id: order_by
  id: order_by
  name: order_by
}

# response of any mutation on the table "document_field_section"
type document_field_section_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_field_section!]!
}

# input type for inserting object relation for remote table "document_field_section"
input document_field_section_obj_rel_insert_input {
  data: document_field_section_insert_input!
  on_conflict: document_field_section_on_conflict
}

# on conflict condition type for table "document_field_section"
input document_field_section_on_conflict {
  constraint: document_field_section_constraint!
  update_columns: [document_field_section_update_column!]!
  where: document_field_section_bool_exp
}

# ordering options when selecting data from "document_field_section"
input document_field_section_order_by {
  description: order_by
  fields_aggregate: document_field_aggregate_order_by
  group: document_field_group_order_by
  group_id: order_by
  id: order_by
  name: order_by
}

# primary key columns input for table: "document_field_section"
input document_field_section_pk_columns_input {
  id: uuid!
}

# select columns of table "document_field_section"
enum document_field_section_select_column {
  # column name
  description

  # column name
  group_id

  # column name
  id

  # column name
  name
}

# input type for updating data in table "document_field_section"
input document_field_section_set_input {
  description: String
  group_id: uuid
  id: uuid
  name: String
}

# update columns of table "document_field_section"
enum document_field_section_update_column {
  # column name
  description

  # column name
  group_id

  # column name
  id

  # column name
  name
}

# A Relay Connection object on "document_field_section"
type document_field_sectionConnection {
  edges: [document_field_sectionEdge!]!
  pageInfo: PageInfo!
}

type document_field_sectionEdge {
  cursor: String!
  node: document_field_section!
}

# select columns of table "document_field"
enum document_field_select_column {
  # column name
  created_at

  # column name
  description

  # column name
  document_type_id

  # column name
  external_id

  # column name
  field_type

  # column name
  id

  # column name
  mandatory

  # column name
  name

  # column name
  order

  # column name
  section_id

  # column name
  updated_at
}

# input type for updating data in table "document_field"
input document_field_set_input {
  created_at: timestamptz
  description: String
  document_type_id: uuid
  external_id: String
  field_type: String
  id: uuid
  mandatory: Boolean
  name: String
  order: Int
  section_id: uuid
  updated_at: timestamptz
}

# aggregate stddev on columns
type document_field_stddev_fields {
  order: Float
}

# order by stddev() on columns of table "document_field"
input document_field_stddev_order_by {
  order: order_by
}

# aggregate stddev_pop on columns
type document_field_stddev_pop_fields {
  order: Float
}

# order by stddev_pop() on columns of table "document_field"
input document_field_stddev_pop_order_by {
  order: order_by
}

# aggregate stddev_samp on columns
type document_field_stddev_samp_fields {
  order: Float
}

# order by stddev_samp() on columns of table "document_field"
input document_field_stddev_samp_order_by {
  order: order_by
}

# aggregate sum on columns
type document_field_sum_fields {
  order: Int
}

# order by sum() on columns of table "document_field"
input document_field_sum_order_by {
  order: order_by
}

# update columns of table "document_field"
enum document_field_update_column {
  # column name
  created_at

  # column name
  description

  # column name
  document_type_id

  # column name
  external_id

  # column name
  field_type

  # column name
  id

  # column name
  mandatory

  # column name
  name

  # column name
  order

  # column name
  section_id

  # column name
  updated_at
}

# columns and relationships of "document_field_value"
type document_field_value implements Node {
  # An object relationship
  document: document
  document_id: uuid

  # An object relationship
  field: document_field
  field_id: uuid
  id: ID!
  value: String
}

# aggregated selection of "document_field_value"
type document_field_value_aggregate {
  aggregate: document_field_value_aggregate_fields
  nodes: [document_field_value!]!
}

# aggregate fields of "document_field_value"
type document_field_value_aggregate_fields {
  count(columns: [document_field_value_select_column!], distinct: Boolean): Int
  max: document_field_value_max_fields
  min: document_field_value_min_fields
}

# order by aggregate values of table "document_field_value"
input document_field_value_aggregate_order_by {
  count: order_by
  max: document_field_value_max_order_by
  min: document_field_value_min_order_by
}

# input type for inserting array relation for remote table "document_field_value"
input document_field_value_arr_rel_insert_input {
  data: [document_field_value_insert_input!]!
  on_conflict: document_field_value_on_conflict
}

# Boolean expression to filter rows from the table "document_field_value". All fields are combined with a logical 'AND'.
input document_field_value_bool_exp {
  _and: [document_field_value_bool_exp]
  _not: document_field_value_bool_exp
  _or: [document_field_value_bool_exp]
  document: document_bool_exp
  document_id: uuid_comparison_exp
  field: document_field_bool_exp
  field_id: uuid_comparison_exp
  id: uuid_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "document_field_value"
enum document_field_value_constraint {
  # unique or primary key constraint
  document_field_value_pkey

  # unique or primary key constraint
  document_field_values_field_id_document_id_key
}

# input type for inserting data into table "document_field_value"
input document_field_value_insert_input {
  document: document_obj_rel_insert_input
  document_id: uuid
  field: document_field_obj_rel_insert_input
  field_id: uuid
  id: uuid
  value: String
}

# aggregate max on columns
type document_field_value_max_fields {
  document_id: uuid
  field_id: uuid
  id: uuid
  value: String
}

# order by max() on columns of table "document_field_value"
input document_field_value_max_order_by {
  document_id: order_by
  field_id: order_by
  id: order_by
  value: order_by
}

# aggregate min on columns
type document_field_value_min_fields {
  document_id: uuid
  field_id: uuid
  id: uuid
  value: String
}

# order by min() on columns of table "document_field_value"
input document_field_value_min_order_by {
  document_id: order_by
  field_id: order_by
  id: order_by
  value: order_by
}

# response of any mutation on the table "document_field_value"
type document_field_value_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_field_value!]!
}

# input type for inserting object relation for remote table "document_field_value"
input document_field_value_obj_rel_insert_input {
  data: document_field_value_insert_input!
  on_conflict: document_field_value_on_conflict
}

# on conflict condition type for table "document_field_value"
input document_field_value_on_conflict {
  constraint: document_field_value_constraint!
  update_columns: [document_field_value_update_column!]!
  where: document_field_value_bool_exp
}

# ordering options when selecting data from "document_field_value"
input document_field_value_order_by {
  document: document_order_by
  document_id: order_by
  field: document_field_order_by
  field_id: order_by
  id: order_by
  value: order_by
}

# primary key columns input for table: "document_field_value"
input document_field_value_pk_columns_input {
  id: uuid!
}

# select columns of table "document_field_value"
enum document_field_value_select_column {
  # column name
  document_id

  # column name
  field_id

  # column name
  id

  # column name
  value
}

# input type for updating data in table "document_field_value"
input document_field_value_set_input {
  document_id: uuid
  field_id: uuid
  id: uuid
  value: String
}

# update columns of table "document_field_value"
enum document_field_value_update_column {
  # column name
  document_id

  # column name
  field_id

  # column name
  id

  # column name
  value
}

# A Relay Connection object on "document_field_value"
type document_field_valueConnection {
  edges: [document_field_valueEdge!]!
  pageInfo: PageInfo!
}

type document_field_valueEdge {
  cursor: String!
  node: document_field_value!
}

# aggregate var_pop on columns
type document_field_var_pop_fields {
  order: Float
}

# order by var_pop() on columns of table "document_field"
input document_field_var_pop_order_by {
  order: order_by
}

# aggregate var_samp on columns
type document_field_var_samp_fields {
  order: Float
}

# order by var_samp() on columns of table "document_field"
input document_field_var_samp_order_by {
  order: order_by
}

# aggregate variance on columns
type document_field_variance_fields {
  order: Float
}

# order by variance() on columns of table "document_field"
input document_field_variance_order_by {
  order: order_by
}

# A Relay Connection object on "document_field"
type document_fieldConnection {
  edges: [document_fieldEdge!]!
  pageInfo: PageInfo!
}

type document_fieldEdge {
  cursor: String!
  node: document_field!
}

# input type for inserting data into table "document"
input document_insert_input {
  created_at: timestamptz
  description: String
  external_id: String
  field_values: document_field_value_arr_rel_insert_input
  id: uuid
  name: String
  type: document_type_obj_rel_insert_input
  type_id: uuid
  updated_at: timestamptz
}

# aggregate max on columns
type document_max_fields {
  created_at: timestamptz
  description: String
  external_id: String
  id: uuid
  name: String
  type_id: uuid
  updated_at: timestamptz
}

# order by max() on columns of table "document"
input document_max_order_by {
  created_at: order_by
  description: order_by
  external_id: order_by
  id: order_by
  name: order_by
  type_id: order_by
  updated_at: order_by
}

# aggregate min on columns
type document_min_fields {
  created_at: timestamptz
  description: String
  external_id: String
  id: uuid
  name: String
  type_id: uuid
  updated_at: timestamptz
}

# order by min() on columns of table "document"
input document_min_order_by {
  created_at: order_by
  description: order_by
  external_id: order_by
  id: order_by
  name: order_by
  type_id: order_by
  updated_at: order_by
}

# response of any mutation on the table "document"
type document_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document!]!
}

# input type for inserting object relation for remote table "document"
input document_obj_rel_insert_input {
  data: document_insert_input!
  on_conflict: document_on_conflict
}

# on conflict condition type for table "document"
input document_on_conflict {
  constraint: document_constraint!
  update_columns: [document_update_column!]!
  where: document_bool_exp
}

# ordering options when selecting data from "document"
input document_order_by {
  created_at: order_by
  description: order_by
  external_id: order_by
  field_values_aggregate: document_field_value_aggregate_order_by
  id: order_by
  name: order_by
  type: document_type_order_by
  type_id: order_by
  updated_at: order_by
}

# primary key columns input for table: "document"
input document_pk_columns_input {
  id: uuid!
}

# columns and relationships of "document_relation"
type document_relation implements Node {
  from_id: uuid!
  id: ID!
  to_id: uuid!
}

# aggregated selection of "document_relation"
type document_relation_aggregate {
  aggregate: document_relation_aggregate_fields
  nodes: [document_relation!]!
}

# aggregate fields of "document_relation"
type document_relation_aggregate_fields {
  count(columns: [document_relation_select_column!], distinct: Boolean): Int
  max: document_relation_max_fields
  min: document_relation_min_fields
}

# order by aggregate values of table "document_relation"
input document_relation_aggregate_order_by {
  count: order_by
  max: document_relation_max_order_by
  min: document_relation_min_order_by
}

# input type for inserting array relation for remote table "document_relation"
input document_relation_arr_rel_insert_input {
  data: [document_relation_insert_input!]!
  on_conflict: document_relation_on_conflict
}

# Boolean expression to filter rows from the table "document_relation". All fields are combined with a logical 'AND'.
input document_relation_bool_exp {
  _and: [document_relation_bool_exp]
  _not: document_relation_bool_exp
  _or: [document_relation_bool_exp]
  from_id: uuid_comparison_exp
  id: uuid_comparison_exp
  to_id: uuid_comparison_exp
}

# unique or primary key constraints on table "document_relation"
enum document_relation_constraint {
  # unique or primary key constraint
  document_relation_pkey
}

# input type for inserting data into table "document_relation"
input document_relation_insert_input {
  from_id: uuid
  id: uuid
  to_id: uuid
}

# aggregate max on columns
type document_relation_max_fields {
  from_id: uuid
  id: uuid
  to_id: uuid
}

# order by max() on columns of table "document_relation"
input document_relation_max_order_by {
  from_id: order_by
  id: order_by
  to_id: order_by
}

# aggregate min on columns
type document_relation_min_fields {
  from_id: uuid
  id: uuid
  to_id: uuid
}

# order by min() on columns of table "document_relation"
input document_relation_min_order_by {
  from_id: order_by
  id: order_by
  to_id: order_by
}

# response of any mutation on the table "document_relation"
type document_relation_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_relation!]!
}

# input type for inserting object relation for remote table "document_relation"
input document_relation_obj_rel_insert_input {
  data: document_relation_insert_input!
  on_conflict: document_relation_on_conflict
}

# on conflict condition type for table "document_relation"
input document_relation_on_conflict {
  constraint: document_relation_constraint!
  update_columns: [document_relation_update_column!]!
  where: document_relation_bool_exp
}

# ordering options when selecting data from "document_relation"
input document_relation_order_by {
  from_id: order_by
  id: order_by
  to_id: order_by
}

# primary key columns input for table: "document_relation"
input document_relation_pk_columns_input {
  id: uuid!
}

# select columns of table "document_relation"
enum document_relation_select_column {
  # column name
  from_id

  # column name
  id

  # column name
  to_id
}

# input type for updating data in table "document_relation"
input document_relation_set_input {
  from_id: uuid
  id: uuid
  to_id: uuid
}

# columns and relationships of "document_relation_type"
type document_relation_type implements Node {
  description: String!
  external_id: String

  # An object relationship
  from: document_type!
  from_id: uuid!

  # An array relationship
  groups(
    # distinct select on columns
    distinct_on: [document_field_group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_group_order_by!]

    # filter the rows returned
    where: document_field_group_bool_exp
  ): [document_field_group!]!

  # An aggregated array relationship
  groups_aggregate(
    # distinct select on columns
    distinct_on: [document_field_group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_group_order_by!]

    # filter the rows returned
    where: document_field_group_bool_exp
  ): document_field_group_aggregate!

  # An array relationship connection
  groups_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_group_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_group_order_by!]

    # filter the rows returned
    where: document_field_group_bool_exp
  ): document_field_groupConnection!
  id: ID!
  name: String!

  # An object relationship
  to: document_type!
  to_id: uuid!
}

# aggregated selection of "document_relation_type"
type document_relation_type_aggregate {
  aggregate: document_relation_type_aggregate_fields
  nodes: [document_relation_type!]!
}

# aggregate fields of "document_relation_type"
type document_relation_type_aggregate_fields {
  count(columns: [document_relation_type_select_column!], distinct: Boolean): Int
  max: document_relation_type_max_fields
  min: document_relation_type_min_fields
}

# order by aggregate values of table "document_relation_type"
input document_relation_type_aggregate_order_by {
  count: order_by
  max: document_relation_type_max_order_by
  min: document_relation_type_min_order_by
}

# input type for inserting array relation for remote table "document_relation_type"
input document_relation_type_arr_rel_insert_input {
  data: [document_relation_type_insert_input!]!
  on_conflict: document_relation_type_on_conflict
}

# Boolean expression to filter rows from the table "document_relation_type". All fields are combined with a logical 'AND'.
input document_relation_type_bool_exp {
  _and: [document_relation_type_bool_exp]
  _not: document_relation_type_bool_exp
  _or: [document_relation_type_bool_exp]
  description: String_comparison_exp
  external_id: String_comparison_exp
  from: document_type_bool_exp
  from_id: uuid_comparison_exp
  groups: document_field_group_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  to: document_type_bool_exp
  to_id: uuid_comparison_exp
}

# unique or primary key constraints on table "document_relation_type"
enum document_relation_type_constraint {
  # unique or primary key constraint
  document_relation_type_pkey
}

# input type for inserting data into table "document_relation_type"
input document_relation_type_insert_input {
  description: String
  external_id: String
  from: document_type_obj_rel_insert_input
  from_id: uuid
  groups: document_field_group_arr_rel_insert_input
  id: uuid
  name: String
  to: document_type_obj_rel_insert_input
  to_id: uuid
}

# aggregate max on columns
type document_relation_type_max_fields {
  description: String
  external_id: String
  from_id: uuid
  id: uuid
  name: String
  to_id: uuid
}

# order by max() on columns of table "document_relation_type"
input document_relation_type_max_order_by {
  description: order_by
  external_id: order_by
  from_id: order_by
  id: order_by
  name: order_by
  to_id: order_by
}

# aggregate min on columns
type document_relation_type_min_fields {
  description: String
  external_id: String
  from_id: uuid
  id: uuid
  name: String
  to_id: uuid
}

# order by min() on columns of table "document_relation_type"
input document_relation_type_min_order_by {
  description: order_by
  external_id: order_by
  from_id: order_by
  id: order_by
  name: order_by
  to_id: order_by
}

# response of any mutation on the table "document_relation_type"
type document_relation_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_relation_type!]!
}

# input type for inserting object relation for remote table "document_relation_type"
input document_relation_type_obj_rel_insert_input {
  data: document_relation_type_insert_input!
  on_conflict: document_relation_type_on_conflict
}

# on conflict condition type for table "document_relation_type"
input document_relation_type_on_conflict {
  constraint: document_relation_type_constraint!
  update_columns: [document_relation_type_update_column!]!
  where: document_relation_type_bool_exp
}

# ordering options when selecting data from "document_relation_type"
input document_relation_type_order_by {
  description: order_by
  external_id: order_by
  from: document_type_order_by
  from_id: order_by
  groups_aggregate: document_field_group_aggregate_order_by
  id: order_by
  name: order_by
  to: document_type_order_by
  to_id: order_by
}

# primary key columns input for table: "document_relation_type"
input document_relation_type_pk_columns_input {
  id: uuid!
}

# select columns of table "document_relation_type"
enum document_relation_type_select_column {
  # column name
  description

  # column name
  external_id

  # column name
  from_id

  # column name
  id

  # column name
  name

  # column name
  to_id
}

# input type for updating data in table "document_relation_type"
input document_relation_type_set_input {
  description: String
  external_id: String
  from_id: uuid
  id: uuid
  name: String
  to_id: uuid
}

# update columns of table "document_relation_type"
enum document_relation_type_update_column {
  # column name
  description

  # column name
  external_id

  # column name
  from_id

  # column name
  id

  # column name
  name

  # column name
  to_id
}

# A Relay Connection object on "document_relation_type"
type document_relation_typeConnection {
  edges: [document_relation_typeEdge!]!
  pageInfo: PageInfo!
}

type document_relation_typeEdge {
  cursor: String!
  node: document_relation_type!
}

# update columns of table "document_relation"
enum document_relation_update_column {
  # column name
  from_id

  # column name
  id

  # column name
  to_id
}

# A Relay Connection object on "document_relation"
type document_relationConnection {
  edges: [document_relationEdge!]!
  pageInfo: PageInfo!
}

type document_relationEdge {
  cursor: String!
  node: document_relation!
}

# select columns of table "document"
enum document_select_column {
  # column name
  created_at

  # column name
  description

  # column name
  external_id

  # column name
  id

  # column name
  name

  # column name
  type_id

  # column name
  updated_at
}

# input type for updating data in table "document"
input document_set_input {
  created_at: timestamptz
  description: String
  external_id: String
  id: uuid
  name: String
  type_id: uuid
  updated_at: timestamptz
}

# columns and relationships of "document_type"
type document_type implements Node {
  # An array relationship
  children_hierarchy(
    # distinct select on columns
    distinct_on: [document_type_hierarchy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_type_hierarchy_order_by!]

    # filter the rows returned
    where: document_type_hierarchy_bool_exp
  ): [document_type_hierarchy!]!

  # An aggregated array relationship
  children_hierarchy_aggregate(
    # distinct select on columns
    distinct_on: [document_type_hierarchy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_type_hierarchy_order_by!]

    # filter the rows returned
    where: document_type_hierarchy_bool_exp
  ): document_type_hierarchy_aggregate!

  # An array relationship connection
  children_hierarchy_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_hierarchy_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_hierarchy_order_by!]

    # filter the rows returned
    where: document_type_hierarchy_bool_exp
  ): document_type_hierarchyConnection!
  color: String!
  created_at: timestamptz
  description: String!
  external_id: String!

  # An array relationship
  fields(
    # distinct select on columns
    distinct_on: [document_field_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_order_by!]

    # filter the rows returned
    where: document_field_bool_exp
  ): [document_field!]!

  # An aggregated array relationship
  fields_aggregate(
    # distinct select on columns
    distinct_on: [document_field_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_order_by!]

    # filter the rows returned
    where: document_field_bool_exp
  ): document_field_aggregate!

  # An array relationship connection
  fields_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_order_by!]

    # filter the rows returned
    where: document_field_bool_exp
  ): document_fieldConnection!

  # An array relationship
  groups(
    # distinct select on columns
    distinct_on: [document_field_group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_group_order_by!]

    # filter the rows returned
    where: document_field_group_bool_exp
  ): [document_field_group!]!

  # An aggregated array relationship
  groups_aggregate(
    # distinct select on columns
    distinct_on: [document_field_group_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_field_group_order_by!]

    # filter the rows returned
    where: document_field_group_bool_exp
  ): document_field_group_aggregate!

  # An array relationship connection
  groups_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_group_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_group_order_by!]

    # filter the rows returned
    where: document_field_group_bool_exp
  ): document_field_groupConnection!

  # An object relationship
  hierarchy: document_type_hierarchy
  hierarchy_id: uuid
  id: ID!
  name: String!

  # An object relationship
  sub_type_of: document_type
  sub_type_of_id: uuid

  # An array relationship
  sub_types(
    # distinct select on columns
    distinct_on: [document_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_type_order_by!]

    # filter the rows returned
    where: document_type_bool_exp
  ): [document_type!]!

  # An aggregated array relationship
  sub_types_aggregate(
    # distinct select on columns
    distinct_on: [document_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [document_type_order_by!]

    # filter the rows returned
    where: document_type_bool_exp
  ): document_type_aggregate!

  # An array relationship connection
  sub_types_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_order_by!]

    # filter the rows returned
    where: document_type_bool_exp
  ): document_typeConnection!
  updated_at: timestamptz

  # An object relationship
  workspace: workspace
  workspace_id: uuid!
}

# aggregated selection of "document_type"
type document_type_aggregate {
  aggregate: document_type_aggregate_fields
  nodes: [document_type!]!
}

# aggregate fields of "document_type"
type document_type_aggregate_fields {
  count(columns: [document_type_select_column!], distinct: Boolean): Int
  max: document_type_max_fields
  min: document_type_min_fields
}

# order by aggregate values of table "document_type"
input document_type_aggregate_order_by {
  count: order_by
  max: document_type_max_order_by
  min: document_type_min_order_by
}

# input type for inserting array relation for remote table "document_type"
input document_type_arr_rel_insert_input {
  data: [document_type_insert_input!]!
  on_conflict: document_type_on_conflict
}

# Boolean expression to filter rows from the table "document_type". All fields are combined with a logical 'AND'.
input document_type_bool_exp {
  _and: [document_type_bool_exp]
  _not: document_type_bool_exp
  _or: [document_type_bool_exp]
  children_hierarchy: document_type_hierarchy_bool_exp
  color: String_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  external_id: String_comparison_exp
  fields: document_field_bool_exp
  groups: document_field_group_bool_exp
  hierarchy: document_type_hierarchy_bool_exp
  hierarchy_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sub_type_of: document_type_bool_exp
  sub_type_of_id: uuid_comparison_exp
  sub_types: document_type_bool_exp
  updated_at: timestamptz_comparison_exp
  workspace: workspace_bool_exp
  workspace_id: uuid_comparison_exp
}

# unique or primary key constraints on table "document_type"
enum document_type_constraint {
  # unique or primary key constraint
  document_type_pkey
}

# columns and relationships of "document_type_hierarchy"
type document_type_hierarchy implements Node {
  id: ID!

  # An object relationship
  parent: document_type!
  parent_id: uuid!
}

# aggregated selection of "document_type_hierarchy"
type document_type_hierarchy_aggregate {
  aggregate: document_type_hierarchy_aggregate_fields
  nodes: [document_type_hierarchy!]!
}

# aggregate fields of "document_type_hierarchy"
type document_type_hierarchy_aggregate_fields {
  count(columns: [document_type_hierarchy_select_column!], distinct: Boolean): Int
  max: document_type_hierarchy_max_fields
  min: document_type_hierarchy_min_fields
}

# order by aggregate values of table "document_type_hierarchy"
input document_type_hierarchy_aggregate_order_by {
  count: order_by
  max: document_type_hierarchy_max_order_by
  min: document_type_hierarchy_min_order_by
}

# input type for inserting array relation for remote table "document_type_hierarchy"
input document_type_hierarchy_arr_rel_insert_input {
  data: [document_type_hierarchy_insert_input!]!
  on_conflict: document_type_hierarchy_on_conflict
}

# Boolean expression to filter rows from the table "document_type_hierarchy". All fields are combined with a logical 'AND'.
input document_type_hierarchy_bool_exp {
  _and: [document_type_hierarchy_bool_exp]
  _not: document_type_hierarchy_bool_exp
  _or: [document_type_hierarchy_bool_exp]
  id: uuid_comparison_exp
  parent: document_type_bool_exp
  parent_id: uuid_comparison_exp
}

# unique or primary key constraints on table "document_type_hierarchy"
enum document_type_hierarchy_constraint {
  # unique or primary key constraint
  document_type_hierarchy_pkey
}

# input type for inserting data into table "document_type_hierarchy"
input document_type_hierarchy_insert_input {
  id: uuid
  parent: document_type_obj_rel_insert_input
  parent_id: uuid
}

# aggregate max on columns
type document_type_hierarchy_max_fields {
  id: uuid
  parent_id: uuid
}

# order by max() on columns of table "document_type_hierarchy"
input document_type_hierarchy_max_order_by {
  id: order_by
  parent_id: order_by
}

# aggregate min on columns
type document_type_hierarchy_min_fields {
  id: uuid
  parent_id: uuid
}

# order by min() on columns of table "document_type_hierarchy"
input document_type_hierarchy_min_order_by {
  id: order_by
  parent_id: order_by
}

# response of any mutation on the table "document_type_hierarchy"
type document_type_hierarchy_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_type_hierarchy!]!
}

# input type for inserting object relation for remote table "document_type_hierarchy"
input document_type_hierarchy_obj_rel_insert_input {
  data: document_type_hierarchy_insert_input!
  on_conflict: document_type_hierarchy_on_conflict
}

# on conflict condition type for table "document_type_hierarchy"
input document_type_hierarchy_on_conflict {
  constraint: document_type_hierarchy_constraint!
  update_columns: [document_type_hierarchy_update_column!]!
  where: document_type_hierarchy_bool_exp
}

# ordering options when selecting data from "document_type_hierarchy"
input document_type_hierarchy_order_by {
  id: order_by
  parent: document_type_order_by
  parent_id: order_by
}

# primary key columns input for table: "document_type_hierarchy"
input document_type_hierarchy_pk_columns_input {
  id: uuid!
}

# select columns of table "document_type_hierarchy"
enum document_type_hierarchy_select_column {
  # column name
  id

  # column name
  parent_id
}

# input type for updating data in table "document_type_hierarchy"
input document_type_hierarchy_set_input {
  id: uuid
  parent_id: uuid
}

# update columns of table "document_type_hierarchy"
enum document_type_hierarchy_update_column {
  # column name
  id

  # column name
  parent_id
}

# A Relay Connection object on "document_type_hierarchy"
type document_type_hierarchyConnection {
  edges: [document_type_hierarchyEdge!]!
  pageInfo: PageInfo!
}

type document_type_hierarchyEdge {
  cursor: String!
  node: document_type_hierarchy!
}

# input type for inserting data into table "document_type"
input document_type_insert_input {
  children_hierarchy: document_type_hierarchy_arr_rel_insert_input
  color: String
  created_at: timestamptz
  description: String
  external_id: String
  fields: document_field_arr_rel_insert_input
  groups: document_field_group_arr_rel_insert_input
  hierarchy: document_type_hierarchy_obj_rel_insert_input
  hierarchy_id: uuid
  id: uuid
  name: String
  sub_type_of: document_type_obj_rel_insert_input
  sub_type_of_id: uuid
  sub_types: document_type_arr_rel_insert_input
  updated_at: timestamptz
  workspace: workspace_obj_rel_insert_input
  workspace_id: uuid
}

# aggregate max on columns
type document_type_max_fields {
  color: String
  created_at: timestamptz
  description: String
  external_id: String
  hierarchy_id: uuid
  id: uuid
  name: String
  sub_type_of_id: uuid
  updated_at: timestamptz
  workspace_id: uuid
}

# order by max() on columns of table "document_type"
input document_type_max_order_by {
  color: order_by
  created_at: order_by
  description: order_by
  external_id: order_by
  hierarchy_id: order_by
  id: order_by
  name: order_by
  sub_type_of_id: order_by
  updated_at: order_by
  workspace_id: order_by
}

# aggregate min on columns
type document_type_min_fields {
  color: String
  created_at: timestamptz
  description: String
  external_id: String
  hierarchy_id: uuid
  id: uuid
  name: String
  sub_type_of_id: uuid
  updated_at: timestamptz
  workspace_id: uuid
}

# order by min() on columns of table "document_type"
input document_type_min_order_by {
  color: order_by
  created_at: order_by
  description: order_by
  external_id: order_by
  hierarchy_id: order_by
  id: order_by
  name: order_by
  sub_type_of_id: order_by
  updated_at: order_by
  workspace_id: order_by
}

# response of any mutation on the table "document_type"
type document_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [document_type!]!
}

# input type for inserting object relation for remote table "document_type"
input document_type_obj_rel_insert_input {
  data: document_type_insert_input!
  on_conflict: document_type_on_conflict
}

# on conflict condition type for table "document_type"
input document_type_on_conflict {
  constraint: document_type_constraint!
  update_columns: [document_type_update_column!]!
  where: document_type_bool_exp
}

# ordering options when selecting data from "document_type"
input document_type_order_by {
  children_hierarchy_aggregate: document_type_hierarchy_aggregate_order_by
  color: order_by
  created_at: order_by
  description: order_by
  external_id: order_by
  fields_aggregate: document_field_aggregate_order_by
  groups_aggregate: document_field_group_aggregate_order_by
  hierarchy: document_type_hierarchy_order_by
  hierarchy_id: order_by
  id: order_by
  name: order_by
  sub_type_of: document_type_order_by
  sub_type_of_id: order_by
  sub_types_aggregate: document_type_aggregate_order_by
  updated_at: order_by
  workspace: workspace_order_by
  workspace_id: order_by
}

# primary key columns input for table: "document_type"
input document_type_pk_columns_input {
  id: uuid!
}

# select columns of table "document_type"
enum document_type_select_column {
  # column name
  color

  # column name
  created_at

  # column name
  description

  # column name
  external_id

  # column name
  hierarchy_id

  # column name
  id

  # column name
  name

  # column name
  sub_type_of_id

  # column name
  updated_at

  # column name
  workspace_id
}

# input type for updating data in table "document_type"
input document_type_set_input {
  color: String
  created_at: timestamptz
  description: String
  external_id: String
  hierarchy_id: uuid
  id: uuid
  name: String
  sub_type_of_id: uuid
  updated_at: timestamptz
  workspace_id: uuid
}

# update columns of table "document_type"
enum document_type_update_column {
  # column name
  color

  # column name
  created_at

  # column name
  description

  # column name
  external_id

  # column name
  hierarchy_id

  # column name
  id

  # column name
  name

  # column name
  sub_type_of_id

  # column name
  updated_at

  # column name
  workspace_id
}

# A Relay Connection object on "document_type"
type document_typeConnection {
  edges: [document_typeEdge!]!
  pageInfo: PageInfo!
}

type document_typeEdge {
  cursor: String!
  node: document_type!
}

# update columns of table "document"
enum document_update_column {
  # column name
  created_at

  # column name
  description

  # column name
  external_id

  # column name
  id

  # column name
  name

  # column name
  type_id

  # column name
  updated_at
}

# A Relay Connection object on "document"
type documentConnection {
  edges: [documentEdge!]!
  pageInfo: PageInfo!
}

type documentEdge {
  cursor: String!
  node: document!
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# mutation root
type mutation_root {
  # delete data from the table: "document"
  delete_document(
    # filter the rows which have to be deleted
    where: document_bool_exp!
  ): document_mutation_response

  # delete single row from the table: "document"
  delete_document_by_pk(id: uuid!): document

  # delete data from the table: "document_field"
  delete_document_field(
    # filter the rows which have to be deleted
    where: document_field_bool_exp!
  ): document_field_mutation_response

  # delete single row from the table: "document_field"
  delete_document_field_by_pk(id: uuid!): document_field

  # delete data from the table: "document_field_group"
  delete_document_field_group(
    # filter the rows which have to be deleted
    where: document_field_group_bool_exp!
  ): document_field_group_mutation_response

  # delete single row from the table: "document_field_group"
  delete_document_field_group_by_pk(id: uuid!): document_field_group

  # delete data from the table: "document_field_section"
  delete_document_field_section(
    # filter the rows which have to be deleted
    where: document_field_section_bool_exp!
  ): document_field_section_mutation_response

  # delete single row from the table: "document_field_section"
  delete_document_field_section_by_pk(id: uuid!): document_field_section

  # delete data from the table: "document_field_value"
  delete_document_field_value(
    # filter the rows which have to be deleted
    where: document_field_value_bool_exp!
  ): document_field_value_mutation_response

  # delete single row from the table: "document_field_value"
  delete_document_field_value_by_pk(id: uuid!): document_field_value

  # delete data from the table: "document_relation"
  delete_document_relation(
    # filter the rows which have to be deleted
    where: document_relation_bool_exp!
  ): document_relation_mutation_response

  # delete single row from the table: "document_relation"
  delete_document_relation_by_pk(id: uuid!): document_relation

  # delete data from the table: "document_relation_type"
  delete_document_relation_type(
    # filter the rows which have to be deleted
    where: document_relation_type_bool_exp!
  ): document_relation_type_mutation_response

  # delete single row from the table: "document_relation_type"
  delete_document_relation_type_by_pk(id: uuid!): document_relation_type

  # delete data from the table: "document_type"
  delete_document_type(
    # filter the rows which have to be deleted
    where: document_type_bool_exp!
  ): document_type_mutation_response

  # delete single row from the table: "document_type"
  delete_document_type_by_pk(id: uuid!): document_type

  # delete data from the table: "document_type_hierarchy"
  delete_document_type_hierarchy(
    # filter the rows which have to be deleted
    where: document_type_hierarchy_bool_exp!
  ): document_type_hierarchy_mutation_response

  # delete single row from the table: "document_type_hierarchy"
  delete_document_type_hierarchy_by_pk(id: uuid!): document_type_hierarchy

  # delete data from the table: "preview_info"
  delete_preview_info(
    # filter the rows which have to be deleted
    where: preview_info_bool_exp!
  ): preview_info_mutation_response

  # delete single row from the table: "preview_info"
  delete_preview_info_by_pk(id: uuid!): preview_info

  # delete data from the table: "preview_info_type"
  delete_preview_info_type(
    # filter the rows which have to be deleted
    where: preview_info_type_bool_exp!
  ): preview_info_type_mutation_response

  # delete single row from the table: "preview_info_type"
  delete_preview_info_type_by_pk(name: String!): preview_info_type

  # delete data from the table: "workspace"
  delete_workspace(
    # filter the rows which have to be deleted
    where: workspace_bool_exp!
  ): workspace_mutation_response

  # delete single row from the table: "workspace"
  delete_workspace_by_pk(id: uuid!): workspace

  # insert data into the table: "document"
  insert_document(
    # the rows to be inserted
    objects: [document_insert_input!]!

    # on conflict condition
    on_conflict: document_on_conflict
  ): document_mutation_response

  # insert data into the table: "document_field"
  insert_document_field(
    # the rows to be inserted
    objects: [document_field_insert_input!]!

    # on conflict condition
    on_conflict: document_field_on_conflict
  ): document_field_mutation_response

  # insert data into the table: "document_field_group"
  insert_document_field_group(
    # the rows to be inserted
    objects: [document_field_group_insert_input!]!

    # on conflict condition
    on_conflict: document_field_group_on_conflict
  ): document_field_group_mutation_response

  # insert a single row into the table: "document_field_group"
  insert_document_field_group_one(
    # the row to be inserted
    object: document_field_group_insert_input!

    # on conflict condition
    on_conflict: document_field_group_on_conflict
  ): document_field_group

  # insert a single row into the table: "document_field"
  insert_document_field_one(
    # the row to be inserted
    object: document_field_insert_input!

    # on conflict condition
    on_conflict: document_field_on_conflict
  ): document_field

  # insert data into the table: "document_field_section"
  insert_document_field_section(
    # the rows to be inserted
    objects: [document_field_section_insert_input!]!

    # on conflict condition
    on_conflict: document_field_section_on_conflict
  ): document_field_section_mutation_response

  # insert a single row into the table: "document_field_section"
  insert_document_field_section_one(
    # the row to be inserted
    object: document_field_section_insert_input!

    # on conflict condition
    on_conflict: document_field_section_on_conflict
  ): document_field_section

  # insert data into the table: "document_field_value"
  insert_document_field_value(
    # the rows to be inserted
    objects: [document_field_value_insert_input!]!

    # on conflict condition
    on_conflict: document_field_value_on_conflict
  ): document_field_value_mutation_response

  # insert a single row into the table: "document_field_value"
  insert_document_field_value_one(
    # the row to be inserted
    object: document_field_value_insert_input!

    # on conflict condition
    on_conflict: document_field_value_on_conflict
  ): document_field_value

  # insert a single row into the table: "document"
  insert_document_one(
    # the row to be inserted
    object: document_insert_input!

    # on conflict condition
    on_conflict: document_on_conflict
  ): document

  # insert data into the table: "document_relation"
  insert_document_relation(
    # the rows to be inserted
    objects: [document_relation_insert_input!]!

    # on conflict condition
    on_conflict: document_relation_on_conflict
  ): document_relation_mutation_response

  # insert a single row into the table: "document_relation"
  insert_document_relation_one(
    # the row to be inserted
    object: document_relation_insert_input!

    # on conflict condition
    on_conflict: document_relation_on_conflict
  ): document_relation

  # insert data into the table: "document_relation_type"
  insert_document_relation_type(
    # the rows to be inserted
    objects: [document_relation_type_insert_input!]!

    # on conflict condition
    on_conflict: document_relation_type_on_conflict
  ): document_relation_type_mutation_response

  # insert a single row into the table: "document_relation_type"
  insert_document_relation_type_one(
    # the row to be inserted
    object: document_relation_type_insert_input!

    # on conflict condition
    on_conflict: document_relation_type_on_conflict
  ): document_relation_type

  # insert data into the table: "document_type"
  insert_document_type(
    # the rows to be inserted
    objects: [document_type_insert_input!]!

    # on conflict condition
    on_conflict: document_type_on_conflict
  ): document_type_mutation_response

  # insert data into the table: "document_type_hierarchy"
  insert_document_type_hierarchy(
    # the rows to be inserted
    objects: [document_type_hierarchy_insert_input!]!

    # on conflict condition
    on_conflict: document_type_hierarchy_on_conflict
  ): document_type_hierarchy_mutation_response

  # insert a single row into the table: "document_type_hierarchy"
  insert_document_type_hierarchy_one(
    # the row to be inserted
    object: document_type_hierarchy_insert_input!

    # on conflict condition
    on_conflict: document_type_hierarchy_on_conflict
  ): document_type_hierarchy

  # insert a single row into the table: "document_type"
  insert_document_type_one(
    # the row to be inserted
    object: document_type_insert_input!

    # on conflict condition
    on_conflict: document_type_on_conflict
  ): document_type

  # insert data into the table: "preview_info"
  insert_preview_info(
    # the rows to be inserted
    objects: [preview_info_insert_input!]!

    # on conflict condition
    on_conflict: preview_info_on_conflict
  ): preview_info_mutation_response

  # insert a single row into the table: "preview_info"
  insert_preview_info_one(
    # the row to be inserted
    object: preview_info_insert_input!

    # on conflict condition
    on_conflict: preview_info_on_conflict
  ): preview_info

  # insert data into the table: "preview_info_type"
  insert_preview_info_type(
    # the rows to be inserted
    objects: [preview_info_type_insert_input!]!

    # on conflict condition
    on_conflict: preview_info_type_on_conflict
  ): preview_info_type_mutation_response

  # insert a single row into the table: "preview_info_type"
  insert_preview_info_type_one(
    # the row to be inserted
    object: preview_info_type_insert_input!

    # on conflict condition
    on_conflict: preview_info_type_on_conflict
  ): preview_info_type

  # insert data into the table: "workspace"
  insert_workspace(
    # the rows to be inserted
    objects: [workspace_insert_input!]!

    # on conflict condition
    on_conflict: workspace_on_conflict
  ): workspace_mutation_response

  # insert a single row into the table: "workspace"
  insert_workspace_one(
    # the row to be inserted
    object: workspace_insert_input!

    # on conflict condition
    on_conflict: workspace_on_conflict
  ): workspace

  # update data of the table: "document"
  update_document(
    # sets the columns of the filtered rows to the given values
    _set: document_set_input

    # filter the rows which have to be updated
    where: document_bool_exp!
  ): document_mutation_response

  # update single row of the table: "document"
  update_document_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_set_input
    pk_columns: document_pk_columns_input!
  ): document

  # update data of the table: "document_field"
  update_document_field(
    # increments the integer columns with given value of the filtered values
    _inc: document_field_inc_input

    # sets the columns of the filtered rows to the given values
    _set: document_field_set_input

    # filter the rows which have to be updated
    where: document_field_bool_exp!
  ): document_field_mutation_response

  # update single row of the table: "document_field"
  update_document_field_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: document_field_inc_input

    # sets the columns of the filtered rows to the given values
    _set: document_field_set_input
    pk_columns: document_field_pk_columns_input!
  ): document_field

  # update data of the table: "document_field_group"
  update_document_field_group(
    # sets the columns of the filtered rows to the given values
    _set: document_field_group_set_input

    # filter the rows which have to be updated
    where: document_field_group_bool_exp!
  ): document_field_group_mutation_response

  # update single row of the table: "document_field_group"
  update_document_field_group_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_field_group_set_input
    pk_columns: document_field_group_pk_columns_input!
  ): document_field_group

  # update data of the table: "document_field_section"
  update_document_field_section(
    # sets the columns of the filtered rows to the given values
    _set: document_field_section_set_input

    # filter the rows which have to be updated
    where: document_field_section_bool_exp!
  ): document_field_section_mutation_response

  # update single row of the table: "document_field_section"
  update_document_field_section_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_field_section_set_input
    pk_columns: document_field_section_pk_columns_input!
  ): document_field_section

  # update data of the table: "document_field_value"
  update_document_field_value(
    # sets the columns of the filtered rows to the given values
    _set: document_field_value_set_input

    # filter the rows which have to be updated
    where: document_field_value_bool_exp!
  ): document_field_value_mutation_response

  # update single row of the table: "document_field_value"
  update_document_field_value_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_field_value_set_input
    pk_columns: document_field_value_pk_columns_input!
  ): document_field_value

  # update data of the table: "document_relation"
  update_document_relation(
    # sets the columns of the filtered rows to the given values
    _set: document_relation_set_input

    # filter the rows which have to be updated
    where: document_relation_bool_exp!
  ): document_relation_mutation_response

  # update single row of the table: "document_relation"
  update_document_relation_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_relation_set_input
    pk_columns: document_relation_pk_columns_input!
  ): document_relation

  # update data of the table: "document_relation_type"
  update_document_relation_type(
    # sets the columns of the filtered rows to the given values
    _set: document_relation_type_set_input

    # filter the rows which have to be updated
    where: document_relation_type_bool_exp!
  ): document_relation_type_mutation_response

  # update single row of the table: "document_relation_type"
  update_document_relation_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_relation_type_set_input
    pk_columns: document_relation_type_pk_columns_input!
  ): document_relation_type

  # update data of the table: "document_type"
  update_document_type(
    # sets the columns of the filtered rows to the given values
    _set: document_type_set_input

    # filter the rows which have to be updated
    where: document_type_bool_exp!
  ): document_type_mutation_response

  # update single row of the table: "document_type"
  update_document_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_type_set_input
    pk_columns: document_type_pk_columns_input!
  ): document_type

  # update data of the table: "document_type_hierarchy"
  update_document_type_hierarchy(
    # sets the columns of the filtered rows to the given values
    _set: document_type_hierarchy_set_input

    # filter the rows which have to be updated
    where: document_type_hierarchy_bool_exp!
  ): document_type_hierarchy_mutation_response

  # update single row of the table: "document_type_hierarchy"
  update_document_type_hierarchy_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: document_type_hierarchy_set_input
    pk_columns: document_type_hierarchy_pk_columns_input!
  ): document_type_hierarchy

  # update data of the table: "preview_info"
  update_preview_info(
    # sets the columns of the filtered rows to the given values
    _set: preview_info_set_input

    # filter the rows which have to be updated
    where: preview_info_bool_exp!
  ): preview_info_mutation_response

  # update single row of the table: "preview_info"
  update_preview_info_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: preview_info_set_input
    pk_columns: preview_info_pk_columns_input!
  ): preview_info

  # update data of the table: "preview_info_type"
  update_preview_info_type(
    # sets the columns of the filtered rows to the given values
    _set: preview_info_type_set_input

    # filter the rows which have to be updated
    where: preview_info_type_bool_exp!
  ): preview_info_type_mutation_response

  # update single row of the table: "preview_info_type"
  update_preview_info_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: preview_info_type_set_input
    pk_columns: preview_info_type_pk_columns_input!
  ): preview_info_type

  # update data of the table: "workspace"
  update_workspace(
    # sets the columns of the filtered rows to the given values
    _set: workspace_set_input

    # filter the rows which have to be updated
    where: workspace_bool_exp!
  ): workspace_mutation_response

  # update single row of the table: "workspace"
  update_workspace_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: workspace_set_input
    pk_columns: workspace_pk_columns_input!
  ): workspace
}

# An object with globally unique ID
interface Node {
  # A globally unique identifier
  id: ID!
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

# columns and relationships of "preview_info"
type preview_info implements Node {
  created_at: timestamptz!

  # An object relationship
  field: document_field!
  field_id: uuid!
  id: ID!
  show: Boolean!
  type: preview_info_type_enum!
  updated_at: timestamptz!
}

# aggregated selection of "preview_info"
type preview_info_aggregate {
  aggregate: preview_info_aggregate_fields
  nodes: [preview_info!]!
}

# aggregate fields of "preview_info"
type preview_info_aggregate_fields {
  count(columns: [preview_info_select_column!], distinct: Boolean): Int
  max: preview_info_max_fields
  min: preview_info_min_fields
}

# order by aggregate values of table "preview_info"
input preview_info_aggregate_order_by {
  count: order_by
  max: preview_info_max_order_by
  min: preview_info_min_order_by
}

# input type for inserting array relation for remote table "preview_info"
input preview_info_arr_rel_insert_input {
  data: [preview_info_insert_input!]!
  on_conflict: preview_info_on_conflict
}

# Boolean expression to filter rows from the table "preview_info". All fields are combined with a logical 'AND'.
input preview_info_bool_exp {
  _and: [preview_info_bool_exp]
  _not: preview_info_bool_exp
  _or: [preview_info_bool_exp]
  created_at: timestamptz_comparison_exp
  field: document_field_bool_exp
  field_id: uuid_comparison_exp
  id: uuid_comparison_exp
  show: Boolean_comparison_exp
  type: preview_info_type_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "preview_info"
enum preview_info_constraint {
  # unique or primary key constraint
  preview_info_field_id_key

  # unique or primary key constraint
  preview_info_pkey
}

# input type for inserting data into table "preview_info"
input preview_info_insert_input {
  created_at: timestamptz
  field: document_field_obj_rel_insert_input
  field_id: uuid
  id: uuid
  show: Boolean
  type: preview_info_type_enum
  updated_at: timestamptz
}

# aggregate max on columns
type preview_info_max_fields {
  created_at: timestamptz
  field_id: uuid
  id: uuid
  updated_at: timestamptz
}

# order by max() on columns of table "preview_info"
input preview_info_max_order_by {
  created_at: order_by
  field_id: order_by
  id: order_by
  updated_at: order_by
}

# aggregate min on columns
type preview_info_min_fields {
  created_at: timestamptz
  field_id: uuid
  id: uuid
  updated_at: timestamptz
}

# order by min() on columns of table "preview_info"
input preview_info_min_order_by {
  created_at: order_by
  field_id: order_by
  id: order_by
  updated_at: order_by
}

# response of any mutation on the table "preview_info"
type preview_info_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [preview_info!]!
}

# input type for inserting object relation for remote table "preview_info"
input preview_info_obj_rel_insert_input {
  data: preview_info_insert_input!
  on_conflict: preview_info_on_conflict
}

# on conflict condition type for table "preview_info"
input preview_info_on_conflict {
  constraint: preview_info_constraint!
  update_columns: [preview_info_update_column!]!
  where: preview_info_bool_exp
}

# ordering options when selecting data from "preview_info"
input preview_info_order_by {
  created_at: order_by
  field: document_field_order_by
  field_id: order_by
  id: order_by
  show: order_by
  type: order_by
  updated_at: order_by
}

# primary key columns input for table: "preview_info"
input preview_info_pk_columns_input {
  id: uuid!
}

# select columns of table "preview_info"
enum preview_info_select_column {
  # column name
  created_at

  # column name
  field_id

  # column name
  id

  # column name
  show

  # column name
  type

  # column name
  updated_at
}

# input type for updating data in table "preview_info"
input preview_info_set_input {
  created_at: timestamptz
  field_id: uuid
  id: uuid
  show: Boolean
  type: preview_info_type_enum
  updated_at: timestamptz
}

# columns and relationships of "preview_info_type"
type preview_info_type implements Node {
  id: ID!
  name: String!
}

# aggregated selection of "preview_info_type"
type preview_info_type_aggregate {
  aggregate: preview_info_type_aggregate_fields
  nodes: [preview_info_type!]!
}

# aggregate fields of "preview_info_type"
type preview_info_type_aggregate_fields {
  count(columns: [preview_info_type_select_column!], distinct: Boolean): Int
  max: preview_info_type_max_fields
  min: preview_info_type_min_fields
}

# order by aggregate values of table "preview_info_type"
input preview_info_type_aggregate_order_by {
  count: order_by
  max: preview_info_type_max_order_by
  min: preview_info_type_min_order_by
}

# input type for inserting array relation for remote table "preview_info_type"
input preview_info_type_arr_rel_insert_input {
  data: [preview_info_type_insert_input!]!
  on_conflict: preview_info_type_on_conflict
}

# Boolean expression to filter rows from the table "preview_info_type". All fields are combined with a logical 'AND'.
input preview_info_type_bool_exp {
  _and: [preview_info_type_bool_exp]
  _not: preview_info_type_bool_exp
  _or: [preview_info_type_bool_exp]
  name: String_comparison_exp
}

# unique or primary key constraints on table "preview_info_type"
enum preview_info_type_constraint {
  # unique or primary key constraint
  preview_info_type_pkey
}

enum preview_info_type_enum {
  badge
  label
}

# expression to compare columns of type preview_info_type_enum. All fields are combined with logical 'AND'.
input preview_info_type_enum_comparison_exp {
  _eq: preview_info_type_enum
  _in: [preview_info_type_enum!]
  _is_null: Boolean
  _neq: preview_info_type_enum
  _nin: [preview_info_type_enum!]
}

# input type for inserting data into table "preview_info_type"
input preview_info_type_insert_input {
  name: String
}

# aggregate max on columns
type preview_info_type_max_fields {
  name: String
}

# order by max() on columns of table "preview_info_type"
input preview_info_type_max_order_by {
  name: order_by
}

# aggregate min on columns
type preview_info_type_min_fields {
  name: String
}

# order by min() on columns of table "preview_info_type"
input preview_info_type_min_order_by {
  name: order_by
}

# response of any mutation on the table "preview_info_type"
type preview_info_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [preview_info_type!]!
}

# input type for inserting object relation for remote table "preview_info_type"
input preview_info_type_obj_rel_insert_input {
  data: preview_info_type_insert_input!
  on_conflict: preview_info_type_on_conflict
}

# on conflict condition type for table "preview_info_type"
input preview_info_type_on_conflict {
  constraint: preview_info_type_constraint!
  update_columns: [preview_info_type_update_column!]!
  where: preview_info_type_bool_exp
}

# ordering options when selecting data from "preview_info_type"
input preview_info_type_order_by {
  name: order_by
}

# primary key columns input for table: "preview_info_type"
input preview_info_type_pk_columns_input {
  name: String!
}

# select columns of table "preview_info_type"
enum preview_info_type_select_column {
  # column name
  name
}

# input type for updating data in table "preview_info_type"
input preview_info_type_set_input {
  name: String
}

# update columns of table "preview_info_type"
enum preview_info_type_update_column {
  # column name
  name
}

# A Relay Connection object on "preview_info_type"
type preview_info_typeConnection {
  edges: [preview_info_typeEdge!]!
  pageInfo: PageInfo!
}

type preview_info_typeEdge {
  cursor: String!
  node: preview_info_type!
}

# update columns of table "preview_info"
enum preview_info_update_column {
  # column name
  created_at

  # column name
  field_id

  # column name
  id

  # column name
  show

  # column name
  type

  # column name
  updated_at
}

# A Relay Connection object on "preview_info"
type preview_infoConnection {
  edges: [preview_infoEdge!]!
  pageInfo: PageInfo!
}

type preview_infoEdge {
  cursor: String!
  node: preview_info!
}

# query root
type query_root {
  # fetch data from the table: "document"
  document_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_order_by!]

    # filter the rows returned
    where: document_bool_exp
  ): documentConnection!

  # fetch data from the table: "document_field"
  document_field_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_order_by!]

    # filter the rows returned
    where: document_field_bool_exp
  ): document_fieldConnection!

  # fetch data from the table: "document_field_group"
  document_field_group_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_group_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_group_order_by!]

    # filter the rows returned
    where: document_field_group_bool_exp
  ): document_field_groupConnection!

  # fetch data from the table: "document_field_section"
  document_field_section_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_section_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_section_order_by!]

    # filter the rows returned
    where: document_field_section_bool_exp
  ): document_field_sectionConnection!

  # fetch data from the table: "document_field_value"
  document_field_value_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_value_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_value_order_by!]

    # filter the rows returned
    where: document_field_value_bool_exp
  ): document_field_valueConnection!

  # fetch data from the table: "document_relation"
  document_relation_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_relation_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_relation_order_by!]

    # filter the rows returned
    where: document_relation_bool_exp
  ): document_relationConnection!

  # fetch data from the table: "document_relation_type"
  document_relation_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_relation_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_relation_type_order_by!]

    # filter the rows returned
    where: document_relation_type_bool_exp
  ): document_relation_typeConnection!

  # fetch data from the table: "document_type"
  document_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_order_by!]

    # filter the rows returned
    where: document_type_bool_exp
  ): document_typeConnection!

  # fetch data from the table: "document_type_hierarchy"
  document_type_hierarchy_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_hierarchy_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_hierarchy_order_by!]

    # filter the rows returned
    where: document_type_hierarchy_bool_exp
  ): document_type_hierarchyConnection!
  node(
    # A globally unique id
    id: ID!
  ): Node

  # fetch data from the table: "preview_info"
  preview_info_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [preview_info_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [preview_info_order_by!]

    # filter the rows returned
    where: preview_info_bool_exp
  ): preview_infoConnection!

  # fetch data from the table: "preview_info_type"
  preview_info_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [preview_info_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [preview_info_type_order_by!]

    # filter the rows returned
    where: preview_info_type_bool_exp
  ): preview_info_typeConnection!

  # fetch data from the table: "workspace"
  workspace_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [workspace_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [workspace_order_by!]

    # filter the rows returned
    where: workspace_bool_exp
  ): workspaceConnection!
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "document"
  document_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_order_by!]

    # filter the rows returned
    where: document_bool_exp
  ): documentConnection!

  # fetch data from the table: "document_field"
  document_field_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_order_by!]

    # filter the rows returned
    where: document_field_bool_exp
  ): document_fieldConnection!

  # fetch data from the table: "document_field_group"
  document_field_group_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_group_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_group_order_by!]

    # filter the rows returned
    where: document_field_group_bool_exp
  ): document_field_groupConnection!

  # fetch data from the table: "document_field_section"
  document_field_section_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_section_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_section_order_by!]

    # filter the rows returned
    where: document_field_section_bool_exp
  ): document_field_sectionConnection!

  # fetch data from the table: "document_field_value"
  document_field_value_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_field_value_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_field_value_order_by!]

    # filter the rows returned
    where: document_field_value_bool_exp
  ): document_field_valueConnection!

  # fetch data from the table: "document_relation"
  document_relation_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_relation_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_relation_order_by!]

    # filter the rows returned
    where: document_relation_bool_exp
  ): document_relationConnection!

  # fetch data from the table: "document_relation_type"
  document_relation_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_relation_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_relation_type_order_by!]

    # filter the rows returned
    where: document_relation_type_bool_exp
  ): document_relation_typeConnection!

  # fetch data from the table: "document_type"
  document_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_order_by!]

    # filter the rows returned
    where: document_type_bool_exp
  ): document_typeConnection!

  # fetch data from the table: "document_type_hierarchy"
  document_type_hierarchy_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [document_type_hierarchy_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [document_type_hierarchy_order_by!]

    # filter the rows returned
    where: document_type_hierarchy_bool_exp
  ): document_type_hierarchyConnection!
  node(
    # A globally unique id
    id: ID!
  ): Node

  # fetch data from the table: "preview_info"
  preview_info_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [preview_info_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [preview_info_order_by!]

    # filter the rows returned
    where: preview_info_bool_exp
  ): preview_infoConnection!

  # fetch data from the table: "preview_info_type"
  preview_info_type_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [preview_info_type_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [preview_info_type_order_by!]

    # filter the rows returned
    where: preview_info_type_bool_exp
  ): preview_info_typeConnection!

  # fetch data from the table: "workspace"
  workspace_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [workspace_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [workspace_order_by!]

    # filter the rows returned
    where: workspace_bool_exp
  ): workspaceConnection!
}

scalar timestamptz

# expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar uuid

# expression to compare columns of type uuid. All fields are combined with logical 'AND'.
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

# columns and relationships of "workspace"
type workspace implements Node {
  active: Boolean
  created_at: timestamptz
  id: ID!
  name: String!
  updated_at: timestamptz
}

# aggregated selection of "workspace"
type workspace_aggregate {
  aggregate: workspace_aggregate_fields
  nodes: [workspace!]!
}

# aggregate fields of "workspace"
type workspace_aggregate_fields {
  count(columns: [workspace_select_column!], distinct: Boolean): Int
  max: workspace_max_fields
  min: workspace_min_fields
}

# order by aggregate values of table "workspace"
input workspace_aggregate_order_by {
  count: order_by
  max: workspace_max_order_by
  min: workspace_min_order_by
}

# input type for inserting array relation for remote table "workspace"
input workspace_arr_rel_insert_input {
  data: [workspace_insert_input!]!
  on_conflict: workspace_on_conflict
}

# Boolean expression to filter rows from the table "workspace". All fields are combined with a logical 'AND'.
input workspace_bool_exp {
  _and: [workspace_bool_exp]
  _not: workspace_bool_exp
  _or: [workspace_bool_exp]
  active: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "workspace"
enum workspace_constraint {
  # unique or primary key constraint
  workspaces_name_key

  # unique or primary key constraint
  workspaces_pkey
}

# input type for inserting data into table "workspace"
input workspace_insert_input {
  active: Boolean
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

# aggregate max on columns
type workspace_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

# order by max() on columns of table "workspace"
input workspace_max_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# aggregate min on columns
type workspace_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

# order by min() on columns of table "workspace"
input workspace_min_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# response of any mutation on the table "workspace"
type workspace_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [workspace!]!
}

# input type for inserting object relation for remote table "workspace"
input workspace_obj_rel_insert_input {
  data: workspace_insert_input!
  on_conflict: workspace_on_conflict
}

# on conflict condition type for table "workspace"
input workspace_on_conflict {
  constraint: workspace_constraint!
  update_columns: [workspace_update_column!]!
  where: workspace_bool_exp
}

# ordering options when selecting data from "workspace"
input workspace_order_by {
  active: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# primary key columns input for table: "workspace"
input workspace_pk_columns_input {
  id: uuid!
}

# select columns of table "workspace"
enum workspace_select_column {
  # column name
  active

  # column name
  created_at

  # column name
  id

  # column name
  name

  # column name
  updated_at
}

# input type for updating data in table "workspace"
input workspace_set_input {
  active: Boolean
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

# update columns of table "workspace"
enum workspace_update_column {
  # column name
  active

  # column name
  created_at

  # column name
  id

  # column name
  name

  # column name
  updated_at
}

# A Relay Connection object on "workspace"
type workspaceConnection {
  edges: [workspaceEdge!]!
  pageInfo: PageInfo!
}

type workspaceEdge {
  cursor: String!
  node: workspace!
}

